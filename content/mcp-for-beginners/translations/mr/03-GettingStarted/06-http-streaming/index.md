<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "5f1383103523fa822e1fec7ef81904d5",
  "translation_date": "2025-08-18T15:47:16+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "mr"
}
-->
# HTTPS स्ट्रीमिंग विथ मॉडेल कॉन्टेक्स्ट प्रोटोकॉल (MCP)

हे प्रकरण HTTPS वापरून मॉडेल कॉन्टेक्स्ट प्रोटोकॉल (MCP) सह सुरक्षित, स्केलेबल आणि रिअल-टाइम स्ट्रीमिंग लागू करण्यासाठी सविस्तर मार्गदर्शक प्रदान करते. यात स्ट्रीमिंगसाठी प्रेरणा, उपलब्ध ट्रान्सपोर्ट मेकॅनिझम्स, MCP मध्ये स्ट्रीमेबल HTTP कसे लागू करावे, सुरक्षा सर्वोत्तम पद्धती, SSE मधून स्थलांतर, आणि तुमचे स्वतःचे MCP स्ट्रीमिंग अॅप्लिकेशन्स तयार करण्यासाठी व्यावहारिक मार्गदर्शन समाविष्ट आहे.

## MCP मधील ट्रान्सपोर्ट मेकॅनिझम्स आणि स्ट्रीमिंग

या विभागात MCP मध्ये उपलब्ध विविध ट्रान्सपोर्ट मेकॅनिझम्स आणि क्लायंट्स व सर्व्हर्समधील रिअल-टाइम संवाद सक्षम करण्यासाठी त्यांच्या भूमिकेचा अभ्यास केला आहे.

### ट्रान्सपोर्ट मेकॅनिझम म्हणजे काय?

ट्रान्सपोर्ट मेकॅनिझम म्हणजे क्लायंट आणि सर्व्हर यांच्यात डेटा कसा देवाणघेवाण होतो हे परिभाषित करते. MCP विविध वातावरण आणि गरजांसाठी अनेक ट्रान्सपोर्ट प्रकारांना समर्थन देते:

- **stdio**: स्थानिक आणि CLI-आधारित साधनांसाठी योग्य. सोपे पण वेब किंवा क्लाउडसाठी योग्य नाही.
- **SSE (सर्व्हर-सेंट इव्हेंट्स)**: HTTP वरून क्लायंटला रिअल-टाइम अपडेट्स पुश करण्यास परवानगी देते. वेब UI साठी चांगले, परंतु स्केलेबिलिटी आणि लवचिकतेत मर्यादित.
- **स्ट्रीमेबल HTTP**: आधुनिक HTTP-आधारित स्ट्रीमिंग ट्रान्सपोर्ट, सूचना आणि चांगल्या स्केलेबिलिटीला समर्थन देते. बहुतेक उत्पादन आणि क्लाउड परिस्थितीसाठी शिफारस केली जाते.

### तुलना तक्ता

खालील तुलना तक्ता पाहून या ट्रान्सपोर्ट मेकॅनिझम्समधील फरक समजून घ्या:

| ट्रान्सपोर्ट         | रिअल-टाइम अपडेट्स | स्ट्रीमिंग | स्केलेबिलिटी | वापर प्रकरण                |
|-------------------|------------------|-----------|-------------|-------------------------|
| stdio             | नाही               | नाही        | कमी         | स्थानिक CLI साधने         |
| SSE               | होय              | होय       | मध्यम      | वेब, रिअल-टाइम अपडेट्स  |
| स्ट्रीमेबल HTTP   | होय              | होय       | उच्च        | क्लाउड, मल्टी-क्लायंट     |

> **टीप:** योग्य ट्रान्सपोर्ट निवडणे कार्यक्षमता, स्केलेबिलिटी आणि वापरकर्ता अनुभवावर परिणाम करते. **स्ट्रीमेबल HTTP** आधुनिक, स्केलेबल आणि क्लाउड-रेडी अॅप्लिकेशन्ससाठी शिफारस केली जाते.

मागील प्रकरणांमध्ये तुम्हाला stdio आणि SSE ट्रान्सपोर्ट्स दाखवले गेले होते आणि या प्रकरणात स्ट्रीमेबल HTTP ट्रान्सपोर्टवर चर्चा केली आहे.

## स्ट्रीमिंग: संकल्पना आणि प्रेरणा

रिअल-टाइम संवाद प्रणाली प्रभावीपणे लागू करण्यासाठी स्ट्रीमिंगच्या मूलभूत संकल्पना आणि प्रेरणा समजून घेणे आवश्यक आहे.

**स्ट्रीमिंग** ही नेटवर्क प्रोग्रामिंगमधील एक तंत्र आहे ज्यामुळे डेटा लहान, व्यवस्थापनीय तुकड्यांमध्ये किंवा इव्हेंट्सच्या अनुक्रमात पाठवला आणि प्राप्त केला जाऊ शकतो, संपूर्ण प्रतिसाद तयार होईपर्यंत प्रतीक्षा करण्याऐवजी. हे विशेषतः उपयुक्त आहे:

- मोठ्या फाइल्स किंवा डेटासेट्ससाठी.
- रिअल-टाइम अपडेट्स (उदा., चॅट, प्रगती पट्ट्या).
- दीर्घकालीन गणना जिथे तुम्हाला वापरकर्त्याला माहिती ठेवायचे आहे.

स्ट्रीमिंगबद्दल उच्च स्तरावर तुम्हाला काय माहित असणे आवश्यक आहे:

- डेटा प्रगतिशीलपणे वितरित केला जातो, एकाच वेळी नाही.
- क्लायंट डेटा आल्यावर प्रक्रिया करू शकतो.
- जाणवलेली विलंबता कमी करते आणि वापरकर्ता अनुभव सुधारतो.

### स्ट्रीमिंग का वापरावे?

स्ट्रीमिंग वापरण्याची कारणे खालीलप्रमाणे आहेत:

- वापरकर्त्यांना त्वरित अभिप्राय मिळतो, शेवटीच नाही.
- रिअल-टाइम अॅप्लिकेशन्स आणि प्रतिसादक्षम UI सक्षम करते.
- नेटवर्क आणि संगणकीय संसाधनांचा अधिक कार्यक्षम वापर.

### सोपा उदाहरण: HTTP स्ट्रीमिंग सर्व्हर आणि क्लायंट

स्ट्रीमिंग कसे लागू करता येते याचे एक सोपे उदाहरण येथे आहे:

#### Python

**सर्व्हर (Python, FastAPI आणि StreamingResponse वापरून):**

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

**क्लायंट (Python, requests वापरून):**

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

हे उदाहरण दाखवते की सर्व्हर क्लायंटला संदेशांची मालिका कशी पाठवतो जेव्हा ते उपलब्ध होतात, सर्व संदेश तयार होईपर्यंत प्रतीक्षा करण्याऐवजी.

**हे कसे कार्य करते:**

- सर्व्हर प्रत्येक संदेश तयार झाल्यावर पाठवतो.
- क्लायंट प्रत्येक तुकडा आल्यावर प्राप्त करतो आणि छापतो.

**आवश्यकता:**

- सर्व्हरने स्ट्रीमिंग प्रतिसाद वापरला पाहिजे (उदा., FastAPI मधील `StreamingResponse`).
- क्लायंटने प्रतिसाद प्रवाह म्हणून प्रक्रिया करणे आवश्यक आहे (`stream=True` requests मध्ये).
- Content-Type सहसा `text/event-stream` किंवा `application/octet-stream` असतो.

#### Java

**सर्व्हर (Java, Spring Boot आणि Server-Sent Events वापरून):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**क्लायंट (Java, Spring WebFlux WebClient वापरून):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Java अंमलबजावणी टीप:**

- `Flux` सह Spring Boot च्या प्रतिक्रियाशील स्टॅकचा वापर करते.
- `ServerSentEvent` इव्हेंट प्रकारांसह संरचित इव्हेंट स्ट्रीमिंग प्रदान करते.
- `bodyToFlux()` सह `WebClient` प्रतिक्रियाशील स्ट्रीमिंग वापर सक्षम करते.
- `delayElements()` इव्हेंट्समधील प्रक्रिया वेळ अनुकरण करते.
- इव्हेंट्समध्ये चांगल्या क्लायंट हाताळणीसाठी प्रकार (`info`, `result`) असू शकतात.

### तुलना: पारंपरिक स्ट्रीमिंग वि MCP स्ट्रीमिंग

"पारंपरिक" पद्धतीने स्ट्रीमिंग कसे कार्य करते आणि MCP मध्ये कसे कार्य करते यातील फरक खालीलप्रमाणे दर्शविला जाऊ शकतो:

| वैशिष्ट्य                | पारंपरिक HTTP स्ट्रीमिंग         | MCP स्ट्रीमिंग (सूचना)      |
|------------------------|-------------------------------|-------------------------------------|
| मुख्य प्रतिसाद          | तुकड्यांमध्ये                       | शेवटी एकच                      |
| प्रगती अपडेट्स       | डेटा तुकड्यांप्रमाणे पाठवले जातात           | सूचना म्हणून पाठवले जातात               |
| क्लायंट आवश्यकता    | प्रवाह प्रक्रिया करणे आवश्यक           | संदेश हँडलर लागू करणे आवश्यक      |
| वापर प्रकरण               | मोठ्या फाइल्स, AI टोकन प्रवाह | प्रगती, लॉग्स, रिअल-टाइम अभिप्राय  |

### निरीक्षण केलेले मुख्य फरक

याशिवाय, काही महत्त्वाचे फरक आहेत:

- **संवाद पद्धती:**
  - पारंपरिक HTTP स्ट्रीमिंग: डेटा तुकड्यांमध्ये पाठवण्यासाठी साधे चंकेड ट्रान्सफर एन्कोडिंग वापरते.
  - MCP स्ट्रीमिंग: JSON-RPC प्रोटोकॉलसह संरचित सूचना प्रणाली वापरते.

- **संदेश स्वरूप:**
  - पारंपरिक HTTP: नवीन ओळींसह साधे मजकूर तुकडे.
  - MCP: मेटाडेटासह संरचित `LoggingMessageNotification` ऑब्जेक्ट्स.

- **क्लायंट अंमलबजावणी:**
  - पारंपरिक HTTP: स्ट्रीमिंग प्रतिसाद प्रक्रिया करणारा साधा क्लायंट.
  - MCP: विविध प्रकारच्या संदेशांवर प्रक्रिया करण्यासाठी संदेश हँडलरसह अधिक प्रगत क्लायंट.

- **प्रगती अपडेट्स:**
  - पारंपरिक HTTP: प्रगती मुख्य प्रतिसाद प्रवाहाचा भाग आहे.
  - MCP: प्रगती स्वतंत्र सूचना संदेशांद्वारे पाठवली जाते, तर मुख्य प्रतिसाद शेवटी येतो.

### शिफारसी

पारंपरिक स्ट्रीमिंग (जसे की `/stream` एंडपॉइंट वापरून दाखवले आहे) लागू करणे आणि MCP द्वारे स्ट्रीमिंग निवडणे यामध्ये निवड करताना आम्ही काही गोष्टी शिफारस करतो:

- **सोप्या स्ट्रीमिंग गरजांसाठी:** पारंपरिक HTTP स्ट्रीमिंग लागू करणे सोपे आहे आणि मूलभूत स्ट्रीमिंग गरजांसाठी पुरेसे आहे.
- **संपूर्ण, परस्परसंवादी अॅप्लिकेशन्ससाठी:** MCP स्ट्रीमिंग अधिक संरचित दृष्टिकोन प्रदान करते, ज्यामध्ये समृद्ध मेटाडेटा आणि सूचना व अंतिम परिणाम यांच्यातील वेगळेपणा आहे.
- **AI अॅप्लिकेशन्ससाठी:** दीर्घकालीन AI कार्यांसाठी वापरकर्त्यांना प्रगतीबद्दल माहिती ठेवण्यासाठी MCP ची सूचना प्रणाली विशेषतः उपयुक्त आहे.

## MCP मधील स्ट्रीमिंग

ठीक आहे, तर तुम्ही आतापर्यंत पारंपरिक स्ट्रीमिंग आणि MCP मधील स्ट्रीमिंगमधील तुलना आणि शिफारसी पाहिल्या आहेत. आता MCP मध्ये स्ट्रीमिंगचा फायदा कसा घ्यायचा याचा तपशील पाहू.

MCP फ्रेमवर्कमध्ये स्ट्रीमिंग कसे कार्य करते हे समजून घेणे, दीर्घकालीन ऑपरेशन्स दरम्यान वापरकर्त्यांना रिअल-टाइम अभिप्राय प्रदान करणाऱ्या प्रतिसादक्षम अॅप्लिकेशन्स तयार करण्यासाठी आवश्यक आहे.

MCP मध्ये, स्ट्रीमिंग म्हणजे मुख्य प्रतिसाद तुकड्यांमध्ये पाठवणे नाही, तर **सूचना** क्लायंटला पाठवणे आहे, जेव्हा एखादे साधन विनंती प्रक्रिया करत असते. या सूचनांमध्ये प्रगती अपडेट्स, लॉग्स किंवा इतर इव्हेंट्स समाविष्ट असू शकतात.

### हे कसे कार्य करते

मुख्य परिणाम अजूनही एकच प्रतिसाद म्हणून पाठवला जातो. तथापि, प्रक्रिया दरम्यान सूचना स्वतंत्र संदेश म्हणून पाठवल्या जाऊ शकतात आणि अशा प्रकारे क्लायंटला रिअल-टाइममध्ये अपडेट केले जाऊ शकते. क्लायंटने या सूचनांना हाताळण्यास आणि प्रदर्शित करण्यास सक्षम असणे आवश्यक आहे.
SSE वरून Streamable HTTP वर अपग्रेड करण्यासाठी दोन महत्त्वाचे कारणे आहेत:

- Streamable HTTP SSE पेक्षा चांगली स्केलेबिलिटी, सुसंगतता आणि अधिक समृद्ध सूचना समर्थन प्रदान करते.
- नवीन MCP अनुप्रयोगांसाठी हे शिफारस केलेले ट्रान्सपोर्ट आहे.

### स्थलांतर चरण

SSE वरून Streamable HTTP वर MCP अनुप्रयोगांमध्ये स्थलांतर कसे करावे:

- **सर्व्हर कोड अपडेट करा** `mcp.run()` मध्ये `transport="streamable-http"` वापरण्यासाठी.
- **क्लायंट कोड अपडेट करा** SSE क्लायंटऐवजी `streamablehttp_client` वापरण्यासाठी.
- **क्लायंटमध्ये संदेश हँडलर लागू करा** सूचनांचे प्रक्रिया करण्यासाठी.
- **सध्याच्या साधनांशी आणि कार्यप्रवाहांशी सुसंगतता तपासा.**

### सुसंगतता राखणे

स्थलांतर प्रक्रियेदरम्यान विद्यमान SSE क्लायंटसह सुसंगतता राखणे शिफारस केले जाते. काही रणनीती येथे दिल्या आहेत:

- तुम्ही SSE आणि Streamable HTTP दोन्ही समर्थन करू शकता वेगवेगळ्या एंडपॉइंट्सवर दोन्ही ट्रान्सपोर्ट चालवून.
- क्लायंट्सना नवीन ट्रान्सपोर्टवर हळूहळू स्थलांतर करा.

### आव्हाने

स्थलांतर करताना खालील आव्हाने सोडवण्याची खात्री करा:

- सर्व क्लायंट्स अपडेट करणे सुनिश्चित करा.
- सूचना वितरणातील फरक हाताळा.

## सुरक्षा विचार

MCP मध्ये HTTP-आधारित ट्रान्सपोर्ट वापरताना कोणत्याही सर्व्हरची अंमलबजावणी करताना सुरक्षा सर्वोच्च प्राधान्य असावी.

HTTP-आधारित ट्रान्सपोर्टसह MCP सर्व्हर अंमलबजावणी करताना, सुरक्षा ही एक महत्त्वाची चिंता बनते ज्यासाठी अनेक हल्ल्याच्या पद्धती आणि संरक्षण यंत्रणा यांचे काळजीपूर्वक लक्ष आवश्यक आहे.

### विहंगावलोकन

MCP सर्व्हर HTTP वर उघड करताना सुरक्षा महत्त्वाची आहे. Streamable HTTP नवीन हल्ल्याच्या पृष्ठभागाची ओळख करून देते आणि काळजीपूर्वक कॉन्फिगरेशन आवश्यक आहे.

महत्त्वाचे सुरक्षा विचार येथे दिले आहेत:

- **Origin Header Validation**: DNS रीबाइंडिंग हल्ले टाळण्यासाठी नेहमी `Origin` हेडरची पडताळणी करा.
- **Localhost Binding**: स्थानिक विकासासाठी, सर्व्हरला `localhost` वर बांधा जेणेकरून ते सार्वजनिक इंटरनेटवर उघड होणार नाहीत.
- **Authentication**: उत्पादनासाठी अंमलबजावणीसाठी प्रमाणीकरण (उदा. API कीज, OAuth) लागू करा.
- **CORS**: क्रॉस-ऑरिजिन रिसोर्स शेअरिंग (CORS) धोरणे कॉन्फिगर करा प्रवेश मर्यादित करण्यासाठी.
- **HTTPS**: उत्पादनात HTTPS वापरा ट्रॅफिक एन्क्रिप्ट करण्यासाठी.

### सर्वोत्तम पद्धती

याशिवाय, MCP स्ट्रीमिंग सर्व्हरमध्ये सुरक्षा अंमलबजावणी करताना खालील सर्वोत्तम पद्धतींचे पालन करा:

- पडताळणीशिवाय येणाऱ्या विनंत्यांवर कधीही विश्वास ठेवू नका.
- सर्व प्रवेश आणि त्रुटी लॉग करा आणि मॉनिटर करा.
- सुरक्षा असुरक्षितता दूर करण्यासाठी नियमितपणे डिपेंडन्सी अपडेट करा.

### आव्हाने

MCP स्ट्रीमिंग सर्व्हरमध्ये सुरक्षा अंमलबजावणी करताना तुम्हाला काही आव्हाने येतील:

- विकास सुलभतेसह सुरक्षा संतुलित करणे.
- विविध क्लायंट वातावरणाशी सुसंगतता सुनिश्चित करणे.

### असाइनमेंट: तुमचा स्वतःचा स्ट्रीमिंग MCP अ‍ॅप तयार करा

**परिस्थिती:**
MCP सर्व्हर आणि क्लायंट तयार करा जिथे सर्व्हर आयटम्सची यादी (उदा. फाइल्स किंवा डॉक्युमेंट्स) प्रक्रिया करतो आणि प्रक्रिया केलेल्या प्रत्येक आयटमसाठी सूचना पाठवतो. क्लायंटने प्रत्येक सूचना येताच प्रदर्शित करावी.

**चरण:**

1. आयटम्सची यादी प्रक्रिया करणारे आणि प्रत्येक आयटमसाठी सूचना पाठवणारे सर्व्हर टूल अंमलात आणा.
2. सूचनांना रिअल टाइममध्ये प्रदर्शित करण्यासाठी संदेश हँडलरसह क्लायंट अंमलात आणा.
3. सर्व्हर आणि क्लायंट चालवून तुमची अंमलबजावणी तपासा आणि सूचनांचे निरीक्षण करा.

[Solution](./solution/README.md)

## पुढील वाचन आणि काय पुढे?

MCP स्ट्रीमिंगसह तुमचा प्रवास सुरू ठेवण्यासाठी आणि तुमचे ज्ञान वाढवण्यासाठी, अधिक प्रगत अनुप्रयोग तयार करण्यासाठी अतिरिक्त संसाधने आणि सुचवलेले पुढील चरण येथे दिले आहेत.

### पुढील वाचन

- [Microsoft: HTTP स्ट्रीमिंगची ओळख](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: ASP.NET Core मध्ये CORS](https://learn.microsoft.com/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: स्ट्रीमिंग विनंत्या](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### काय पुढे?

- रिअल टाइम अ‍ॅनालिटिक्स, चॅट किंवा सहयोगी संपादनासाठी स्ट्रीमिंग वापरणारे अधिक प्रगत MCP टूल्स तयार करण्याचा प्रयत्न करा.
- लाइव्ह UI अपडेट्ससाठी फ्रंटएंड फ्रेमवर्क (React, Vue, इ.) सह MCP स्ट्रीमिंग एकत्रित करण्याचा शोध घ्या.
- पुढे: [VSCode साठी AI टूलकिटचा उपयोग](../07-aitk/README.md)

**अस्वीकरण**:  
हा दस्तऐवज AI भाषांतर सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) चा वापर करून भाषांतरित करण्यात आला आहे. आम्ही अचूकतेसाठी प्रयत्नशील असलो तरी, कृपया लक्षात घ्या की स्वयंचलित भाषांतरांमध्ये त्रुटी किंवा अचूकतेचा अभाव असू शकतो. मूळ भाषेतील मूळ दस्तऐवज हा अधिकृत स्रोत मानला जावा. महत्त्वाच्या माहितीसाठी व्यावसायिक मानवी भाषांतराची शिफारस केली जाते. या भाषांतराचा वापर केल्यामुळे उद्भवणाऱ्या कोणत्याही गैरसमज किंवा चुकीच्या अर्थासाठी आम्ही जबाबदार राहणार नाही.