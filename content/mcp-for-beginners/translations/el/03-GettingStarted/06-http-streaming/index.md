<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "5f1383103523fa822e1fec7ef81904d5",
  "translation_date": "2025-08-18T14:00:45+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "el"
}
-->
# HTTPS Streaming με το Πρωτόκολλο Model Context (MCP)

Αυτό το κεφάλαιο παρέχει έναν ολοκληρωμένο οδηγό για την υλοποίηση ασφαλούς, επεκτάσιμης και σε πραγματικό χρόνο ροής δεδομένων με το Πρωτόκολλο Model Context (MCP) χρησιμοποιώντας HTTPS. Καλύπτει τη σημασία της ροής, τους διαθέσιμους μηχανισμούς μεταφοράς, πώς να υλοποιήσετε ροή HTTP στο MCP, βέλτιστες πρακτικές ασφαλείας, τη μετάβαση από SSE και πρακτικές οδηγίες για την ανάπτυξη δικών σας εφαρμογών ροής MCP.

## Μηχανισμοί Μεταφοράς και Ροή στο MCP

Αυτή η ενότητα εξετάζει τους διάφορους μηχανισμούς μεταφοράς που είναι διαθέσιμοι στο MCP και τον ρόλο τους στην ενεργοποίηση δυνατοτήτων ροής για επικοινωνία σε πραγματικό χρόνο μεταξύ πελατών και διακομιστών.

### Τι είναι ένας Μηχανισμός Μεταφοράς;

Ένας μηχανισμός μεταφοράς ορίζει πώς ανταλλάσσονται δεδομένα μεταξύ του πελάτη και του διακομιστή. Το MCP υποστηρίζει πολλούς τύπους μεταφοράς για να καλύψει διαφορετικά περιβάλλοντα και απαιτήσεις:

- **stdio**: Είσοδος/έξοδος μέσω κονσόλας, κατάλληλο για τοπικά εργαλεία και εργαλεία γραμμής εντολών. Απλό αλλά όχι κατάλληλο για web ή cloud.
- **SSE (Server-Sent Events)**: Επιτρέπει στους διακομιστές να στέλνουν ενημερώσεις σε πραγματικό χρόνο στους πελάτες μέσω HTTP. Καλό για web UIs, αλλά περιορισμένο σε επεκτασιμότητα και ευελιξία.
- **Streamable HTTP**: Σύγχρονος μηχανισμός ροής μέσω HTTP, που υποστηρίζει ειδοποιήσεις και καλύτερη επεκτασιμότητα. Συνιστάται για τις περισσότερες παραγωγικές και cloud περιπτώσεις.

### Πίνακας Σύγκρισης

Δείτε τον παρακάτω πίνακα για να κατανοήσετε τις διαφορές μεταξύ αυτών των μηχανισμών μεταφοράς:

| Μεταφορά          | Ενημερώσεις σε Πραγματικό Χρόνο | Ροή       | Επεκτασιμότητα | Περίπτωση Χρήσης         |
|-------------------|-------------------------------|-----------|----------------|--------------------------|
| stdio             | Όχι                          | Όχι        | Χαμηλή         | Τοπικά εργαλεία CLI       |
| SSE               | Ναι                          | Ναι        | Μεσαία         | Web, ενημερώσεις σε πραγματικό χρόνο |
| Streamable HTTP   | Ναι                          | Ναι        | Υψηλή          | Cloud, πολλαπλοί πελάτες |

> **Συμβουλή:** Η επιλογή του σωστού μηχανισμού μεταφοράς επηρεάζει την απόδοση, την επεκτασιμότητα και την εμπειρία χρήστη. Το **Streamable HTTP** συνιστάται για σύγχρονες, επεκτάσιμες και έτοιμες για cloud εφαρμογές.

Σημειώστε τους μηχανισμούς μεταφοράς stdio και SSE που παρουσιάστηκαν στα προηγούμενα κεφάλαια και πώς το Streamable HTTP είναι ο μηχανισμός που καλύπτεται σε αυτό το κεφάλαιο.

## Ροή: Έννοιες και Κίνητρα

Η κατανόηση των βασικών εννοιών και των κινήτρων πίσω από τη ροή είναι απαραίτητη για την υλοποίηση αποτελεσματικών συστημάτων επικοινωνίας σε πραγματικό χρόνο.

**Η Ροή** είναι μια τεχνική στον προγραμματισμό δικτύων που επιτρέπει τη μετάδοση και λήψη δεδομένων σε μικρά, διαχειρίσιμα τμήματα ή ως ακολουθία γεγονότων, αντί να περιμένουμε να είναι έτοιμη ολόκληρη η απάντηση. Αυτό είναι ιδιαίτερα χρήσιμο για:

- Μεγάλα αρχεία ή σύνολα δεδομένων.
- Ενημερώσεις σε πραγματικό χρόνο (π.χ., συνομιλίες, γραμμές προόδου).
- Μακροχρόνιες υπολογιστικές διαδικασίες όπου θέλετε να ενημερώνετε τον χρήστη.

Ακολουθούν τα βασικά που πρέπει να γνωρίζετε για τη ροή:

- Τα δεδομένα παραδίδονται προοδευτικά, όχι όλα μαζί.
- Ο πελάτης μπορεί να επεξεργαστεί τα δεδομένα καθώς φτάνουν.
- Μειώνει την αντιληπτή καθυστέρηση και βελτιώνει την εμπειρία χρήστη.

### Γιατί να χρησιμοποιήσετε τη ροή;

Οι λόγοι για τη χρήση της ροής είναι οι εξής:

- Οι χρήστες λαμβάνουν άμεση ανατροφοδότηση, όχι μόνο στο τέλος.
- Επιτρέπει εφαρμογές σε πραγματικό χρόνο και διαδραστικά περιβάλλοντα.
- Κάνει πιο αποδοτική τη χρήση των πόρων δικτύου και υπολογιστών.

### Απλό Παράδειγμα: Διακομιστής και Πελάτης Ροής HTTP

Ακολουθεί ένα απλό παράδειγμα για το πώς μπορεί να υλοποιηθεί η ροή:

#### Python

**Διακομιστής (Python, χρησιμοποιώντας FastAPI και StreamingResponse):**

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

**Πελάτης (Python, χρησιμοποιώντας requests):**

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

Αυτό το παράδειγμα δείχνει έναν διακομιστή που στέλνει μια σειρά μηνυμάτων στον πελάτη καθώς αυτά γίνονται διαθέσιμα, αντί να περιμένει να είναι έτοιμα όλα τα μηνύματα.

**Πώς λειτουργεί:**

- Ο διακομιστής αποστέλλει κάθε μήνυμα μόλις είναι έτοιμο.
- Ο πελάτης λαμβάνει και εκτυπώνει κάθε τμήμα καθώς φτάνει.

**Απαιτήσεις:**

- Ο διακομιστής πρέπει να χρησιμοποιεί μια απόκριση ροής (π.χ., `StreamingResponse` στο FastAPI).
- Ο πελάτης πρέπει να επεξεργάζεται την απόκριση ως ροή (`stream=True` στο requests).
- Το Content-Type είναι συνήθως `text/event-stream` ή `application/octet-stream`.

#### Java

**Διακομιστής (Java, χρησιμοποιώντας Spring Boot και Server-Sent Events):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**Πελάτης (Java, χρησιμοποιώντας Spring WebFlux WebClient):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Σημειώσεις Υλοποίησης Java:**

- Χρησιμοποιεί το αντιδραστικό stack του Spring Boot με `Flux` για ροή.
- Το `ServerSentEvent` παρέχει δομημένη ροή γεγονότων με τύπους γεγονότων.
- Το `WebClient` με `bodyToFlux()` επιτρέπει αντιδραστική κατανάλωση ροής.
- Το `delayElements()` προσομοιώνει χρόνο επεξεργασίας μεταξύ γεγονότων.
- Τα γεγονότα μπορούν να έχουν τύπους (`info`, `result`) για καλύτερο χειρισμό από τον πελάτη.

### Σύγκριση: Κλασική Ροή έναντι Ροής MCP

Οι διαφορές μεταξύ της "κλασικής" ροής και της ροής στο MCP μπορούν να παρουσιαστούν ως εξής:

| Χαρακτηριστικό         | Κλασική Ροή HTTP            | Ροή MCP (Ειδοποιήσεις)            |
|------------------------|----------------------------|-----------------------------------|
| Κύρια απόκριση         | Σε τμήματα                 | Ενιαία, στο τέλος                |
| Ενημερώσεις προόδου    | Αποστέλλονται ως τμήματα δεδομένων | Αποστέλλονται ως ειδοποιήσεις   |
| Απαιτήσεις πελάτη      | Πρέπει να επεξεργάζεται τη ροή | Πρέπει να υλοποιεί διαχειριστή μηνυμάτων |
| Περίπτωση χρήσης       | Μεγάλα αρχεία, ροές AI tokens | Πρόοδος, logs, ανατροφοδότηση σε πραγματικό χρόνο |

### Παρατηρούμενες Διαφορές

Επιπλέον, ορισμένες βασικές διαφορές περιλαμβάνουν:

- **Μοτίβο Επικοινωνίας:**
  - Κλασική Ροή HTTP: Χρησιμοποιεί απλή κωδικοποίηση μεταφοράς σε τμήματα για αποστολή δεδομένων.
  - Ροή MCP: Χρησιμοποιεί δομημένο σύστημα ειδοποιήσεων με το πρωτόκολλο JSON-RPC.

- **Μορφή Μηνύματος:**
  - Κλασική HTTP: Απλά τμήματα κειμένου με νέες γραμμές.
  - MCP: Δομημένα αντικείμενα LoggingMessageNotification με μεταδεδομένα.

- **Υλοποίηση Πελάτη:**
  - Κλασική HTTP: Απλός πελάτης που επεξεργάζεται αποκρίσεις ροής.
  - MCP: Πιο εξελιγμένος πελάτης με διαχειριστή μηνυμάτων για επεξεργασία διαφορετικών τύπων μηνυμάτων.

- **Ενημερώσεις Προόδου:**
  - Κλασική HTTP: Η πρόοδος είναι μέρος της κύριας ροής απόκρισης.
  - MCP: Η πρόοδος αποστέλλεται μέσω ξεχωριστών μηνυμάτων ειδοποίησης, ενώ η κύρια απόκριση έρχεται στο τέλος.

### Συστάσεις

Υπάρχουν ορισμένες συστάσεις σχετικά με την επιλογή μεταξύ υλοποίησης κλασικής ροής (όπως το endpoint `/stream` που παρουσιάστηκε παραπάνω) και ροής μέσω MCP.

- **Για απλές ανάγκες ροής:** Η κλασική ροή HTTP είναι πιο απλή στην υλοποίηση και επαρκής για βασικές ανάγκες ροής.
- **Για σύνθετες, διαδραστικές εφαρμογές:** Η ροή MCP παρέχει μια πιο δομημένη προσέγγιση με πλουσιότερα μεταδεδομένα και διαχωρισμό μεταξύ ειδοποιήσεων και τελικών αποτελεσμάτων.
- **Για εφαρμογές AI:** Το σύστημα ειδοποιήσεων του MCP είναι ιδιαίτερα χρήσιμο για μακροχρόνιες εργασίες AI, όπου θέλετε να ενημερώνετε τους χρήστες για την πρόοδο.
Υπάρχουν δύο ισχυροί λόγοι για να αναβαθμίσετε από SSE σε Streamable HTTP:

- Το Streamable HTTP προσφέρει καλύτερη επεκτασιμότητα, συμβατότητα και πιο πλούσια υποστήριξη ειδοποιήσεων από το SSE.
- Είναι η προτεινόμενη μέθοδος μεταφοράς για νέες εφαρμογές MCP.

### Βήματα Μετάβασης

Ακολουθούν τα βήματα για να μεταβείτε από SSE σε Streamable HTTP στις εφαρμογές MCP σας:

- **Ενημερώστε τον κώδικα του διακομιστή** ώστε να χρησιμοποιεί `transport="streamable-http"` στο `mcp.run()`.
- **Ενημερώστε τον κώδικα του πελάτη** ώστε να χρησιμοποιεί `streamablehttp_client` αντί για τον SSE client.
- **Υλοποιήστε έναν χειριστή μηνυμάτων** στον πελάτη για την επεξεργασία ειδοποιήσεων.
- **Δοκιμάστε τη συμβατότητα** με τα υπάρχοντα εργαλεία και τις ροές εργασίας.

### Διατήρηση Συμβατότητας

Συνιστάται να διατηρήσετε τη συμβατότητα με τους υπάρχοντες SSE πελάτες κατά τη διαδικασία μετάβασης. Ακολουθούν κάποιες στρατηγικές:

- Μπορείτε να υποστηρίξετε τόσο το SSE όσο και το Streamable HTTP εκτελώντας και τις δύο μεθόδους μεταφοράς σε διαφορετικά endpoints.
- Μεταφέρετε σταδιακά τους πελάτες στη νέα μέθοδο μεταφοράς.

### Προκλήσεις

Βεβαιωθείτε ότι αντιμετωπίζετε τις παρακάτω προκλήσεις κατά τη μετάβαση:

- Ενημέρωση όλων των πελατών
- Διαχείριση διαφορών στην παράδοση ειδοποιήσεων

## Σκέψεις Ασφαλείας

Η ασφάλεια πρέπει να είναι η κορυφαία προτεραιότητα κατά την υλοποίηση οποιουδήποτε διακομιστή, ειδικά όταν χρησιμοποιούνται μέθοδοι μεταφοράς βασισμένες στο HTTP, όπως το Streamable HTTP στο MCP.

Κατά την υλοποίηση διακομιστών MCP με μεταφορές βασισμένες στο HTTP, η ασφάλεια γίνεται κρίσιμη και απαιτεί προσεκτική προσοχή σε πολλαπλές επιθέσεις και μηχανισμούς προστασίας.

### Επισκόπηση

Η ασφάλεια είναι ζωτικής σημασίας όταν εκθέτετε διακομιστές MCP μέσω HTTP. Το Streamable HTTP εισάγει νέες επιφάνειες επίθεσης και απαιτεί προσεκτική διαμόρφωση.

Ακολουθούν ορισμένες βασικές σκέψεις ασφαλείας:

- **Επικύρωση της κεφαλίδας Origin**: Επικυρώστε πάντα την κεφαλίδα `Origin` για να αποτρέψετε επιθέσεις DNS rebinding.
- **Δέσμευση στο localhost**: Για τοπική ανάπτυξη, δεσμεύστε τους διακομιστές στο `localhost` για να αποφύγετε την έκθεσή τους στο δημόσιο διαδίκτυο.
- **Αυθεντικοποίηση**: Υλοποιήστε αυθεντικοποίηση (π.χ. API keys, OAuth) για παραγωγικές εγκαταστάσεις.
- **CORS**: Διαμορφώστε πολιτικές Cross-Origin Resource Sharing (CORS) για να περιορίσετε την πρόσβαση.
- **HTTPS**: Χρησιμοποιήστε HTTPS στην παραγωγή για την κρυπτογράφηση της κυκλοφορίας.

### Βέλτιστες Πρακτικές

Επιπλέον, ακολουθούν κάποιες βέλτιστες πρακτικές για την υλοποίηση της ασφάλειας στον διακομιστή MCP streaming:

- Μην εμπιστεύεστε εισερχόμενα αιτήματα χωρίς επικύρωση.
- Καταγράψτε και παρακολουθήστε όλη την πρόσβαση και τα σφάλματα.
- Ενημερώνετε τακτικά τις εξαρτήσεις για να διορθώνετε ευπάθειες ασφαλείας.

### Προκλήσεις

Θα αντιμετωπίσετε κάποιες προκλήσεις κατά την υλοποίηση της ασφάλειας στους διακομιστές MCP streaming:

- Ισορροπία μεταξύ ασφάλειας και ευκολίας ανάπτυξης
- Εξασφάλιση συμβατότητας με διάφορα περιβάλλοντα πελατών

### Εργασία: Δημιουργήστε τη δική σας εφαρμογή MCP streaming

**Σενάριο:**
Δημιουργήστε έναν διακομιστή και έναν πελάτη MCP όπου ο διακομιστής επεξεργάζεται μια λίστα αντικειμένων (π.χ. αρχεία ή έγγραφα) και στέλνει μια ειδοποίηση για κάθε αντικείμενο που επεξεργάζεται. Ο πελάτης θα πρέπει να εμφανίζει κάθε ειδοποίηση μόλις φτάσει.

**Βήματα:**

1. Υλοποιήστε ένα εργαλείο διακομιστή που επεξεργάζεται μια λίστα και στέλνει ειδοποιήσεις για κάθε αντικείμενο.
2. Υλοποιήστε έναν πελάτη με έναν χειριστή μηνυμάτων για να εμφανίζει ειδοποιήσεις σε πραγματικό χρόνο.
3. Δοκιμάστε την υλοποίησή σας εκτελώντας και τον διακομιστή και τον πελάτη, και παρατηρήστε τις ειδοποιήσεις.

[Solution](./solution/README.md)

## Περαιτέρω Ανάγνωση & Τι Ακολουθεί;

Για να συνεχίσετε το ταξίδι σας με το MCP streaming και να επεκτείνετε τις γνώσεις σας, αυτή η ενότητα παρέχει πρόσθετους πόρους και προτεινόμενα επόμενα βήματα για την ανάπτυξη πιο προηγμένων εφαρμογών.

### Περαιτέρω Ανάγνωση

- [Microsoft: Εισαγωγή στο HTTP Streaming](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: CORS στο ASP.NET Core](https://learn.microsoft.com/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: Streaming Requests](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### Τι Ακολουθεί;

- Δοκιμάστε να δημιουργήσετε πιο προηγμένα εργαλεία MCP που χρησιμοποιούν streaming για ανάλυση σε πραγματικό χρόνο, συνομιλία ή συνεργατική επεξεργασία.
- Εξερευνήστε την ενσωμάτωση του MCP streaming με frontend frameworks (React, Vue, κ.λπ.) για ζωντανές ενημερώσεις UI.
- Επόμενο: [Χρήση του AI Toolkit για το VSCode](../07-aitk/README.md)

**Αποποίηση Ευθύνης**:  
Αυτό το έγγραφο έχει μεταφραστεί χρησιμοποιώντας την υπηρεσία αυτόματης μετάφρασης [Co-op Translator](https://github.com/Azure/co-op-translator). Παρόλο που καταβάλλουμε κάθε προσπάθεια για ακρίβεια, παρακαλούμε να έχετε υπόψη ότι οι αυτόματες μεταφράσεις ενδέχεται να περιέχουν λάθη ή ανακρίβειες. Το πρωτότυπο έγγραφο στη μητρική του γλώσσα θα πρέπει να θεωρείται η αυθεντική πηγή. Για κρίσιμες πληροφορίες, συνιστάται επαγγελματική ανθρώπινη μετάφραση. Δεν φέρουμε ευθύνη για τυχόν παρεξηγήσεις ή εσφαλμένες ερμηνείες που προκύπτουν από τη χρήση αυτής της μετάφρασης.