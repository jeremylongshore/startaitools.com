<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "69372338676e01a2c97f42f70fdfbf42",
  "translation_date": "2025-08-26T20:25:49+00:00",
  "source_file": "03-GettingStarted/05-stdio-server/solution/dotnet/README.md",
  "language_code": "bg"
}
-->
# MCP stdio Server - .NET Решение

> **⚠️ Важно**: Това решение е актуализирано да използва **stdio транспорт**, както е препоръчано в MCP Спецификация 2025-06-18. Оригиналният SSE транспорт е остарял.

## Общ преглед

Това .NET решение демонстрира как да изградите MCP сървър, използвайки текущия stdio транспорт. Stdio транспортът е по-прост, по-сигурен и осигурява по-добра производителност в сравнение с остарелия SSE подход.

## Предварителни изисквания

- .NET 9.0 SDK или по-нова версия
- Основни познания за .NET dependency injection

## Инструкции за настройка

### Стъпка 1: Възстановяване на зависимости

```bash
dotnet restore
```

### Стъпка 2: Компилиране на проекта

```bash
dotnet build
```

## Стартиране на сървъра

Stdio сървърът работи по различен начин от стария сървър, базиран на HTTP. Вместо да стартира уеб сървър, той комуникира чрез stdin/stdout:

```bash
dotnet run
```

**Важно**: Сървърът ще изглежда сякаш е "замръзнал" - това е нормално! Той чака JSON-RPC съобщения от stdin.

## Тестване на сървъра

### Метод 1: Използване на MCP Inspector (Препоръчително)

```bash
npx @modelcontextprotocol/inspector dotnet run
```

Това ще:
1. Стартира вашия сървър като подпроцес
2. Отвори уеб интерфейс за тестване
3. Позволи интерактивно тестване на всички инструменти на сървъра

### Метод 2: Тестване директно от командния ред

Можете също да тествате, като стартирате Inspector директно:

```bash
npx @modelcontextprotocol/inspector dotnet run --project .
```

### Налични инструменти

Сървърът предоставя следните инструменти:

- **AddNumbers(a, b)**: Събира две числа
- **MultiplyNumbers(a, b)**: Умножава две числа  
- **GetGreeting(name)**: Генерира персонализиран поздрав
- **GetServerInfo()**: Предоставя информация за сървъра

### Тестване с Claude Desktop

За да използвате този сървър с Claude Desktop, добавете следната конфигурация към вашия `claude_desktop_config.json`:

```json
{
  "mcpServers": {
    "example-stdio-server": {
      "command": "dotnet",
      "args": ["run", "--project", "path/to/server.csproj"]
    }
  }
}
```

## Структура на проекта

```
dotnet/
├── Program.cs           # Main server setup and configuration
├── Tools.cs            # Tool implementations
├── server.csproj       # Project file with dependencies
├── server.sln         # Solution file
├── Properties/         # Project properties
└── README.md          # This file
```

## Основни разлики от HTTP/SSE

**stdio транспорт (Текущ):**
- ✅ По-проста настройка - не е необходим уеб сървър
- ✅ По-добра сигурност - няма HTTP крайни точки
- ✅ Използва `Host.CreateApplicationBuilder()` вместо `WebApplication.CreateBuilder()`
- ✅ `WithStdioTransport()` вместо `WithHttpTransport()`
- ✅ Конзолно приложение вместо уеб приложение
- ✅ По-добра производителност

**HTTP/SSE транспорт (Остарял):**
- ❌ Изискваше ASP.NET Core уеб сървър
- ❌ Нуждаеше се от настройка на маршрутизация с `app.MapMcp()`
- ❌ По-сложна конфигурация и зависимости
- ❌ Допълнителни съображения за сигурност
- ❌ Вече е остарял в MCP 2025-06-18

## Функции за разработка

- **Dependency Injection**: Пълна поддръжка на DI за услуги и логване
- **Структурирано логване**: Коректно логване към stderr чрез `ILogger<T>`
- **Tool Attributes**: Чисто дефиниране на инструменти с помощта на `[McpServerTool]` атрибути
- **Поддръжка на Async**: Всички инструменти поддържат асинхронни операции
- **Обработка на грешки**: Гъвкава обработка на грешки и логване

## Съвети за разработка

- Използвайте `ILogger` за логване (никога не пишете директно към stdout)
- Компилирайте с `dotnet build` преди тестване
- Тествайте с Inspector за визуално отстраняване на грешки
- Всички логове автоматично отиват към stderr
- Сървърът обработва сигнали за плавно спиране

Това решение следва текущата MCP спецификация и демонстрира най-добрите практики за имплементация на stdio транспорт с .NET.

---

**Отказ от отговорност**:  
Този документ е преведен с помощта на AI услуга за превод [Co-op Translator](https://github.com/Azure/co-op-translator). Въпреки че се стремим към точност, моля, имайте предвид, че автоматизираните преводи може да съдържат грешки или неточности. Оригиналният документ на неговия изходен език трябва да се счита за авторитетен източник. За критична информация се препоръчва професионален превод от човек. Ние не носим отговорност за каквито и да е недоразумения или погрешни интерпретации, произтичащи от използването на този превод.