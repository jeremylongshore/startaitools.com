<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "904b59de1de9264801242d90a42cdd9d",
  "translation_date": "2025-09-05T10:46:08+00:00",
  "source_file": "01-CoreConcepts/README.md",
  "language_code": "ne"
}
-->
# MCP कोर अवधारणाहरू: एआई एकीकरणको लागि मोडेल कन्टेक्स्ट प्रोटोकलको मास्टरी

[![MCP कोर अवधारणाहरू](../../../translated_images/02.8203e26c6fb5a797f38a10012061013ec66c95bb3260f6c9cfd2bf74b00860e1.ne.png)](https://youtu.be/earDzWGtE84)

_(माथिको चित्रमा क्लिक गरेर यस पाठको भिडियो हेर्नुहोस्)_

[मोडेल कन्टेक्स्ट प्रोटोकल (MCP)](https://github.com/modelcontextprotocol) एक शक्तिशाली, मानकीकृत फ्रेमवर्क हो जसले ठूलो भाषा मोडेल (LLMs) र बाह्य उपकरणहरू, एप्लिकेसनहरू, र डाटा स्रोतहरू बीचको सञ्चारलाई अनुकूलित गर्दछ।  
यस मार्गदर्शनले तपाईंलाई MCP को कोर अवधारणाहरूमा लैजानेछ। तपाईं यसको क्लाइन्ट-सर्भर आर्किटेक्चर, आवश्यक घटकहरू, सञ्चार यान्त्रिकी, र कार्यान्वयनको उत्कृष्ट अभ्यासहरूबारे सिक्नुहुनेछ।

- **स्पष्ट प्रयोगकर्ता सहमति**: सबै डाटा पहुँच र अपरेशनहरू कार्यान्वयन गर्नु अघि स्पष्ट प्रयोगकर्ता अनुमोदन आवश्यक छ। प्रयोगकर्ताहरूले कुन डाटा पहुँच गरिनेछ र कुन कार्यहरू गरिनेछ भन्ने स्पष्ट रूपमा बुझ्नुपर्छ, अनुमति र प्राधिकरणहरूमा विस्तृत नियन्त्रणको साथ।

- **डाटा गोपनीयता संरक्षण**: प्रयोगकर्ता डाटा केवल स्पष्ट सहमतिसँग मात्र खुलासा गरिन्छ र सम्पूर्ण अन्तरक्रिया चक्रमा बलियो पहुँच नियन्त्रणद्वारा सुरक्षित गर्नुपर्छ। कार्यान्वयनहरूले अनधिकृत डाटा प्रसारण रोक्नुपर्छ र कडा गोपनीयता सीमाहरू कायम राख्नुपर्छ।

- **उपकरण कार्यान्वयन सुरक्षा**: प्रत्येक उपकरणको आह्वान स्पष्ट प्रयोगकर्ता सहमति आवश्यक छ, उपकरणको कार्यक्षमता, प्यारामिटरहरू, र सम्भावित प्रभावको स्पष्ट बुझाइको साथ। अनपेक्षित, असुरक्षित, वा दुर्भावनापूर्ण उपकरण कार्यान्वयन रोक्न बलियो सुरक्षा सीमाहरू आवश्यक छ।

- **ट्रान्सपोर्ट लेयर सुरक्षा**: सबै सञ्चार च्यानलहरूले उपयुक्त इन्क्रिप्शन र प्रमाणीकरण संयन्त्रहरू प्रयोग गर्नुपर्छ। रिमोट कनेक्शनहरूले सुरक्षित ट्रान्सपोर्ट प्रोटोकलहरू र उचित क्रेडेन्शियल व्यवस्थापन कार्यान्वयन गर्नुपर्छ।

#### कार्यान्वयन दिशानिर्देशहरू:

- **अनुमति व्यवस्थापन**: प्रयोगकर्ताहरूलाई कुन सर्भरहरू, उपकरणहरू, र स्रोतहरू पहुँचयोग्य छन् भन्ने नियन्त्रण गर्न अनुमति दिने विस्तृत अनुमति प्रणालीहरू कार्यान्वयन गर्नुहोस्।  
- **प्रमाणीकरण र प्राधिकरण**: सुरक्षित प्रमाणीकरण विधिहरू (OAuth, API कुञ्जीहरू) उचित टोकन व्यवस्थापन र समाप्तिको साथ प्रयोग गर्नुहोस्।  
- **इनपुट मान्यता**: परिभाषित स्किमाहरू अनुसार सबै प्यारामिटरहरू र डाटा इनपुटहरू मान्यता दिनुहोस् ताकि इन्जेक्शन आक्रमणहरू रोक्न सकियोस्।  
- **अडिट लगिङ**: सुरक्षा निगरानी र अनुपालनको लागि सबै अपरेशनहरूको व्यापक लगहरू कायम राख्नुहोस्।  

## अवलोकन

यस पाठले मोडेल कन्टेक्स्ट प्रोटोकल (MCP) इकोसिस्टम बनाउने मौलिक आर्किटेक्चर र घटकहरूको अन्वेषण गर्दछ। तपाईं MCP अन्तरक्रियाहरूलाई शक्ति दिने क्लाइन्ट-सर्भर आर्किटेक्चर, प्रमुख घटकहरू, र सञ्चार यान्त्रिकीबारे सिक्नुहुनेछ।

## प्रमुख सिकाइ उद्देश्यहरू

यस पाठको अन्त्यसम्ममा, तपाईं:

- MCP क्लाइन्ट-सर्भर आर्किटेक्चर बुझ्नुहुनेछ।  
- होस्टहरू, क्लाइन्टहरू, र सर्भरहरूको भूमिका र जिम्मेवारीहरू पहिचान गर्नुहुनेछ।  
- MCP लाई एक लचिलो एकीकरण तह बनाउने कोर सुविधाहरूको विश्लेषण गर्नुहुनेछ।  
- MCP इकोसिस्टमभित्र जानकारी प्रवाह कसरी हुन्छ भन्ने सिक्नुहुनेछ।  
- .NET, Java, Python, र JavaScript मा कोड उदाहरणहरू मार्फत व्यावहारिक अन्तर्दृष्टि प्राप्त गर्नुहुनेछ।  

## MCP आर्किटेक्चर: गहिरो दृष्टिकोण

MCP इकोसिस्टम क्लाइन्ट-सर्भर मोडेलमा निर्माण गरिएको छ। यो मोड्युलर संरचनाले एआई एप्लिकेसनहरूलाई उपकरणहरू, डाटाबेसहरू, API हरू, र सन्दर्भ स्रोतहरूसँग कुशलतापूर्वक अन्तरक्रिया गर्न अनुमति दिन्छ। आउनुहोस् यस आर्किटेक्चरलाई यसको कोर घटकहरूमा विभाजन गरौं।

MCP को केन्द्रमा क्लाइन्ट-सर्भर आर्किटेक्चर छ जहाँ होस्ट एप्लिकेसनले धेरै सर्भरहरूसँग जडान गर्न सक्छ:

```mermaid
flowchart LR
    subgraph "Your Computer"
        Host["Host with MCP (Visual Studio, VS Code, IDEs, Tools)"]
        S1["MCP Server A"]
        S2["MCP Server B"]
        S3["MCP Server C"]
        Host <-->|"MCP Protocol"| S1
        Host <-->|"MCP Protocol"| S2
        Host <-->|"MCP Protocol"| S3
        S1 <--> D1[("Local\Data Source A")]
        S2 <--> D2[("Local\Data Source B")]
    end
    subgraph "Internet"
        S3 <-->|"Web APIs"| D3[("Remote\Services")]
    end
```

- **MCP होस्टहरू**: VSCode, Claude Desktop, IDEs, वा MCP मार्फत डाटा पहुँच गर्न चाहने एआई उपकरणहरू जस्ता कार्यक्रमहरू।  
- **MCP क्लाइन्टहरू**: सर्भरहरूसँग 1:1 जडान कायम राख्ने प्रोटोकल क्लाइन्टहरू।  
- **MCP सर्भरहरू**: प्रत्येकले मानकीकृत मोडेल कन्टेक्स्ट प्रोटोकल मार्फत विशिष्ट क्षमताहरू उजागर गर्ने हल्का कार्यक्रमहरू।  
- **स्थानीय डाटा स्रोतहरू**: MCP सर्भरहरूले सुरक्षित रूपमा पहुँच गर्न सक्ने तपाईंको कम्प्युटरका फाइलहरू, डाटाबेसहरू, र सेवाहरू।  
- **रिमोट सेवाहरू**: API हरू मार्फत MCP सर्भरहरूले जडान गर्न सक्ने इन्टरनेटमा उपलब्ध बाह्य प्रणालीहरू।  

MCP प्रोटोकल एक विकसित मानक हो जसले मिति-आधारित संस्करणिङ (YYYY-MM-DD ढाँचा) प्रयोग गर्दछ। हालको प्रोटोकल संस्करण **2025-06-18** हो। तपाईं [प्रोटोकल विशिष्टता](https://modelcontextprotocol.io/specification/2025-06-18/) मा पछिल्लो अपडेटहरू हेर्न सक्नुहुन्छ।

### 1. होस्टहरू

मोडेल कन्टेक्स्ट प्रोटोकल (MCP) मा, **होस्टहरू** एआई एप्लिकेसनहरू हुन् जसले प्रयोगकर्ताहरूलाई प्रोटोकलसँग अन्तरक्रिया गर्न प्राथमिक इन्टरफेसको रूपमा सेवा दिन्छ। होस्टहरूले धेरै MCP सर्भरहरूसँग जडानहरू व्यवस्थापन र समन्वय गर्छन् प्रत्येक सर्भर जडानको लागि समर्पित MCP क्लाइन्टहरू सिर्जना गरेर। होस्टहरूको उदाहरणहरूमा समावेश छन्:

- **एआई एप्लिकेसनहरू**: Claude Desktop, Visual Studio Code, Claude Code।  
- **विकास वातावरणहरू**: MCP एकीकरणको साथ IDE हरू र कोड सम्पादकहरू।  
- **अनुकूलित एप्लिकेसनहरू**: उद्देश्य-निर्मित एआई एजेन्टहरू र उपकरणहरू।  

**होस्टहरू** एप्लिकेसनहरू हुन् जसले एआई मोडेल अन्तरक्रियाहरू समन्वय गर्छन्। तिनीहरूले:

- **एआई मोडेलहरू समन्वय गर्नुहोस्**: प्रतिक्रिया उत्पन्न गर्न वा एआई वर्कफ्लोहरू समन्वय गर्न LLM हरूसँग अन्तरक्रिया गर्नुहोस्।  
- **क्लाइन्ट जडानहरू व्यवस्थापन गर्नुहोस्**: प्रत्येक MCP सर्भर जडानको लागि एक MCP क्लाइन्ट सिर्जना र कायम राख्नुहोस्।  
- **प्रयोगकर्ता इन्टरफेस नियन्त्रण गर्नुहोस्**: वार्तालाप प्रवाह, प्रयोगकर्ता अन्तरक्रिया, र प्रतिक्रिया प्रस्तुति व्यवस्थापन गर्नुहोस्।  
- **सुरक्षा लागू गर्नुहोस्**: अनुमति, सुरक्षा सीमाहरू, र प्रमाणीकरण नियन्त्रण गर्नुहोस्।  
- **प्रयोगकर्ता सहमति व्यवस्थापन गर्नुहोस्**: डाटा साझेदारी र उपकरण कार्यान्वयनको लागि प्रयोगकर्ता अनुमोदन व्यवस्थापन गर्नुहोस्।  

### 2. क्लाइन्टहरू

**क्लाइन्टहरू** आवश्यक घटकहरू हुन् जसले होस्टहरू र MCP सर्भरहरू बीच समर्पित एक-देखि-एक जडानहरू कायम राख्छन्। प्रत्येक MCP क्लाइन्ट होस्टद्वारा एक विशिष्ट MCP सर्भरसँग जडान गर्न सुरु गरिन्छ, व्यवस्थित र सुरक्षित सञ्चार च्यानलहरू सुनिश्चित गर्दै। धेरै क्लाइन्टहरूले होस्टहरूलाई एकै समयमा धेरै सर्भरहरूसँग जडान गर्न सक्षम बनाउँछन्।

**क्लाइन्टहरू** होस्ट एप्लिकेसन भित्रका कनेक्टर घटकहरू हुन्। तिनीहरूले:

- **प्रोटोकल सञ्चार**: सर्भरहरूलाई JSON-RPC 2.0 अनुरोधहरू प्रेषित गर्नुहोस्।  
- **क्षमता वार्ता**: सुरुवातको क्रममा सर्भरहरूसँग समर्थित सुविधाहरू र प्रोटोकल संस्करणहरू वार्ता गर्नुहोस्।  
- **उपकरण कार्यान्वयन**: मोडेलहरूबाट उपकरण कार्यान्वयन अनुरोधहरू व्यवस्थापन गर्नुहोस्।  
- **रियल-टाइम अपडेटहरू**: सर्भरहरूबाट सूचनाहरू र वास्तविक समय अपडेटहरू व्यवस्थापन गर्नुहोस्।  
- **प्रतिक्रिया प्रशोधन**: प्रयोगकर्ताहरूलाई प्रदर्शनको लागि सर्भर प्रतिक्रियाहरू प्रशोधन र ढाँचाबद्ध गर्नुहोस्।  

### 3. सर्भरहरू

**सर्भरहरू** प्रोग्रामहरू हुन् जसले MCP क्लाइन्टहरूलाई सन्दर्भ, उपकरणहरू, र क्षमताहरू प्रदान गर्छन्। तिनीहरू स्थानीय रूपमा (होस्टसँग एउटै मेसिनमा) वा रिमोट रूपमा (बाह्य प्लेटफर्महरूमा) कार्यान्वयन गर्न सकिन्छ, र क्लाइन्ट अनुरोधहरू व्यवस्थापन गर्न र संरचित प्रतिक्रियाहरू प्रदान गर्न जिम्मेवार छन्। सर्भरहरूले मानकीकृत मोडेल कन्टेक्स्ट प्रोटोकल मार्फत विशिष्ट कार्यक्षमता उजागर गर्छन्।

**सर्भरहरू** सेवाहरू हुन् जसले सन्दर्भ र क्षमताहरू प्रदान गर्छन्। तिनीहरूले:

- **फिचर दर्ता**: उपलब्ध प्रिमिटिभहरू (स्रोतहरू, प्रम्प्टहरू, उपकरणहरू) क्लाइन्टहरूमा दर्ता र उजागर गर्नुहोस्।  
- **अनुरोध प्रशोधन**: क्लाइन्टहरूबाट उपकरण कलहरू, स्रोत अनुरोधहरू, र प्रम्प्ट अनुरोधहरू प्राप्त गर्नुहोस्।  
- **सन्दर्भ प्रावधान**: मोडेल प्रतिक्रियाहरू सुधार गर्न सन्दर्भ जानकारी र डाटा प्रदान गर्नुहोस्।  
- **राज्य व्यवस्थापन**: सत्र अवस्था कायम राख्नुहोस् र आवश्यक परेमा राज्यपूर्ण अन्तरक्रियाहरू व्यवस्थापन गर्नुहोस्।  
- **रियल-टाइम सूचनाहरू**: जडान गरिएका क्लाइन्टहरूमा क्षमता परिवर्तनहरू र अपडेटहरूबारे सूचनाहरू पठाउनुहोस्।  

सर्भरहरू जो कोहीले विकास गर्न सक्छन् ताकि मोडेल क्षमताहरूलाई विशेष कार्यक्षमतासँग विस्तार गर्न सकियोस्, र तिनीहरूले स्थानीय र रिमोट कार्यान्वयन परिदृश्यहरू समर्थन गर्छन्।  

### 4. सर्भर प्रिमिटिभहरू

मोडेल कन्टेक्स्ट प्रोटोकल (MCP) मा सर्भरहरूले तीन कोर **प्रिमिटिभहरू** प्रदान गर्छन् जसले क्लाइन्टहरू, होस्टहरू, र भाषा मोडेलहरू बीचको समृद्ध अन्तरक्रियाहरूको लागि मौलिक निर्माण ब्लकहरू परिभाषित गर्छन्।  

MCP सर्भरहरूले निम्न तीन कोर प्रिमिटिभहरूको कुनै पनि संयोजन उजागर गर्न सक्छन्:

#### स्रोतहरू  

**स्रोतहरू** डाटा स्रोतहरू हुन् जसले एआई एप्लिकेसनहरूलाई सन्दर्भ जानकारी प्रदान गर्छन्। तिनीहरूले स्थिर वा गतिशील सामग्रीलाई प्रतिनिधित्व गर्छन् जसले मोडेलको बुझाइ र निर्णय-निर्माणलाई सुधार गर्न सक्छ।  

- **सन्दर्भ डाटा**: एआई मोडेल उपभोगको लागि संरचित जानकारी।  
- **ज्ञान आधारहरू**: दस्तावेज भण्डारहरू, लेखहरू, म्यानुअलहरू, र अनुसन्धान पत्रहरू।  
- **स्थानीय डाटा स्रोतहरू**: फाइलहरू, डाटाबेसहरू, र स्थानीय प्रणाली जानकारी।  
- **बाह्य डाटा**: API प्रतिक्रियाहरू, वेब सेवाहरू, र रिमोट प्रणाली डाटा।  
- **गतिशील सामग्री**: बाह्य अवस्थाहरूमा आधारित वास्तविक समय डाटा।  

स्रोतहरू URI हरूद्वारा पहिचान गरिन्छ र `resources/list` मार्फत पत्ता लगाउन र `resources/read` विधिहरू मार्फत पुनःप्राप्त गर्न समर्थन गर्दछ:

```text
file://documents/project-spec.md
database://production/users/schema
api://weather/current
```

#### प्रम्प्टहरू  

**प्रम्प्टहरू** पुन: प्रयोग गर्न मिल्ने टेम्प्लेटहरू हुन् जसले भाषा मोडेलहरूसँग अन्तरक्रियाहरू संरचना गर्न मद्दत गर्छन्। तिनीहरूले मानकीकृत अन्तरक्रिया ढाँचाहरू र टेम्प्लेट गरिएको वर्कफ्लोहरू प्रदान गर्छन्।  

- **टेम्प्लेट-आधारित अन्तरक्रियाहरू**: पूर्व-संरचित सन्देशहरू र वार्तालाप सुरूवातकर्ताहरू।  
- **वर्कफ्लो टेम्प्लेटहरू**: सामान्य कार्यहरू र अन्तरक्रियाहरूको लागि मानकीकृत क्रमहरू।  
- **फ्यू-शट उदाहरणहरू**: मोडेल निर्देशनको लागि उदाहरण-आधारित टेम्प्लेटहरू।  
- **सिस्टम प्रम्प्टहरू**: मोडेल व्यवहार र सन्दर्भ परिभाषित गर्ने आधारभूत प्रम्प्टहरू।  
- **गतिशील टेम्प्लेटहरू**: विशिष्ट सन्दर्भहरूमा अनुकूलन हुने प्यारामिटरयुक्त प्रम्प्टहरू।  

प्रम्प्टहरूले भेरिएबल प्रतिस्थापनलाई समर्थन गर्छन् र `prompts/list` मार्फत पत्ता लगाउन र `prompts/get` मार्फत पुनःप्राप्त गर्न सकिन्छ:

```markdown
Generate a {{task_type}} for {{product}} targeting {{audience}} with the following requirements: {{requirements}}
```

#### उपकरणहरू  

**उपकरणहरू** कार्यान्वयन योग्य कार्यहरू हुन् जसलाई एआई मोडेलहरूले विशिष्ट कार्यहरू गर्न आह्वान गर्न सक्छन्। तिनीहरूले MCP इकोसिस्टमका "क्रियाहरू" प्रतिनिधित्व गर्छन्, जसले मोडेलहरूलाई बाह्य प्रणालीहरूसँग अन्तरक्रिया गर्न सक्षम बनाउँछ।  

- **कार्यान्वयन योग्य कार्यहरू**: विशिष्ट प्यारामिटरहरूसँग मोडेलहरूले आह्वान गर्न सक्ने छुट्टै अपरेशनहरू।  
- **बाह्य प्रणाली एकीकरण**: API कलहरू, डाटाबेस क्वेरीहरू, फाइल अपरेशनहरू, गणनाहरू।  
- **अद्वितीय पहिचान**: प्रत्येक उपकरणको छुट्टै नाम, विवरण, र प्यारामिटर स्किमा हुन्छ।  
- **संरचित I/O**: उपकरणहरूले मान्यता प्राप्त प्यारामिटरहरू स्वीकार गर्छन् र संरचित, टाइप गरिएको प्रतिक्रियाहरू फर्काउँछन्।  
- **कार्य क्षमताहरू**: मोडेलहरूलाई वास्तविक-विश्व कार्यहरू प्रदर्शन गर्न र प्रत्यक्ष डाटा पुनःप्राप्त गर्न सक्षम बनाउनुहोस्।  

उपकरणहरू प्यारामिटर मान्यताका लागि JSON स्किमा संग परिभाषित गरिन्छ र `tools/list` मार्फत पत्ता लगाउन र `tools/call` मार्फत कार्यान्वयन गर्न सकिन्छ:

```typescript
server.tool(
  "search_products", 
  {
    query: z.string().describe("Search query for products"),
    category: z.string().optional().describe("Product category filter"),
    max_results: z.number().default(10).describe("Maximum results to return")
  }, 
  async (params) => {
    // Execute search and return structured results
    return await productService.search(params);
  }
);
```

## क्लाइन्ट प्रिमिटिभहरू  

मोडेल कन्टेक्स्ट प्रोटोकल (MCP) मा, **क्लाइन्टहरू** प्रिमिटिभहरू उजागर गर्न सक्छन् जसले सर्भरहरूलाई होस्ट एप्लिकेसनबाट अतिरिक्त क्षमताहरू अनुरोध गर्न सक्षम बनाउँछ।  

### स्याम्पलिङ  

**स्याम्पलिङ** सर्भरहरूलाई क्लाइन्टको एआई एप्लिकेसनबाट भाषा मोडेल कम्प्लिसन अनुरोध गर्न अनुमति दिन्छ।  

### एलिसिटेसन  

**एलिसिटेसन** सर्भरहरूलाई क्लाइन्ट इन्टरफेस मार्फत प्रयोगकर्ताहरूबाट अतिरिक्त जानकारी वा पुष्टि अनुरोध गर्न सक्षम बनाउँछ।  

### लगिङ  

**लगिङ** सर्भरहरूलाई क्लाइन्टहरूमा संरचित लग सन्देशहरू पठाउन अनुमति दिन्छ।  

## MCP मा जानकारी प्रवाह  

मोडेल कन्टेक्स्ट प्रोटोकल (MCP) ले होस्टहरू, क्लाइन्टहरू, सर्भरहरू, र मोडेलहरू बीचको जानकारीको संरचित प्रवाह परिभाषित गर्दछ।  

- **होस्ट जडान सुरु गर्छ**  
  होस्ट एप्लिकेसनले MCP सर्भरसँग जडान स्थापना गर्छ।  

- **क्षमता वार्ता**  
  क्लाइन्ट र सर्भरले सत्रको लागि उपलब्ध सुविधाहरूको आदानप्रदान गर्छन्।  

- **प्रयोगकर्ता अनुरोध**  
  प्रयोगकर्ताले होस्टसँग अन्तरक्रिया गर्छ।  

- **स्रोत वा उपकरण प्रयोग**  
  - क्लाइन्टले सर्भरबाट अतिरिक्त सन्दर्भ वा स्रोत अनुरोध गर्न सक्छ।  
  - मोडेलले उपकरण आवश्यक ठानेमा, क्लाइन्टले उपकरण आह्वान अनुरोध सर्भरमा पठाउँछ।  

- **सर्भर कार्यान्वयन**  
  सर्भरले अनुरोध प्राप्त गर्छ र आवश्यक अपरेशनहरू कार्यान्वयन गर्छ।  

- **प्रतिक्रिया उत्पादन**  
  क्लाइन्टले सर्भरको प्रतिक्रियालाई मोडेल अन्तरक्रियामा समाहित गर्छ।  

- **परिणाम प्रस्तुति**  
  होस्टले अन्तिम आउटपुट प्रयोगकर्तालाई प्रस्तुत गर्छ।  

## प्रोटोकल आर्किटेक्चर र तहहरू  

MCP दुई अलग आर्किटेक्चरल तहहरूमा आधारित छ।  

### डाटा तह  

**डाटा तह** ले **JSON-RPC 2.0** प्रयोग गरेर कोर MCP प्रोटोकल कार्यान्वयन गर्छ।  

#### कोर घटक:  
- **JSON-RPC 2.0 प्रोटोकल**: सबै संचारले विधि कल, प्रतिक्रिया, र सूचनाहरूको लागि मानकीकृत JSON-RPC 2.0 सन्देश ढाँचा प्रयोग गर्दछ  
- **लाइफसाइकल व्यवस्थापन**: क्लाइन्ट र सर्भरहरू बीच जडान आरम्भ, क्षमता वार्ता, र सत्र समाप्ति व्यवस्थापन गर्दछ  
- **सर्भर प्रिमिटिभहरू**: सर्भरहरूलाई उपकरणहरू, स्रोतहरू, र प्रम्प्टहरू मार्फत मुख्य कार्यक्षमता प्रदान गर्न सक्षम बनाउँछ  
- **क्लाइन्ट प्रिमिटिभहरू**: सर्भरहरूलाई LLM बाट नमूना अनुरोध गर्न, प्रयोगकर्ताको इनपुट प्राप्त गर्न, र लग सन्देशहरू पठाउन सक्षम बनाउँछ  
- **रियल-टाइम सूचनाहरू**: पोलिङ बिना गतिशील अपडेटहरूको लागि असिंक्रोनस सूचनाहरूलाई समर्थन गर्दछ  

#### मुख्य विशेषताहरू:

- **प्रोटोकल संस्करण वार्ता**: अनुकूलता सुनिश्चित गर्न मिति-आधारित संस्करण (YYYY-MM-DD) प्रयोग गर्दछ  
- **क्षमता पत्ता लगाउने**: आरम्भको क्रममा क्लाइन्ट र सर्भरहरूले समर्थित सुविधाहरूको जानकारी आदानप्रदान गर्छन्  
- **स्टेटफुल सत्रहरू**: सन्दर्भ निरन्तरताको लागि धेरै अन्तरक्रियाहरूमा जडान स्थिति कायम राख्छ  

### ट्रान्सपोर्ट लेयर

**ट्रान्सपोर्ट लेयर** ले MCP सहभागीहरू बीच संचार च्यानलहरू, सन्देश फ्रेमिङ, र प्रमाणीकरण व्यवस्थापन गर्दछ:

#### समर्थित ट्रान्सपोर्ट संयन्त्रहरू:

1. **STDIO ट्रान्सपोर्ट**:
   - प्रत्यक्ष प्रक्रिया संचारको लागि मानक इनपुट/आउटपुट स्ट्रिमहरू प्रयोग गर्दछ  
   - एउटै मेसिनमा स्थानीय प्रक्रियाहरूको लागि उपयुक्त, कुनै नेटवर्क ओभरहेड बिना  
   - प्रायः स्थानीय MCP सर्भर कार्यान्वयनहरूको लागि प्रयोग गरिन्छ  

2. **स्ट्रीमेबल HTTP ट्रान्सपोर्ट**:
   - क्लाइन्ट-देखि-सर्भर सन्देशहरूको लागि HTTP POST प्रयोग गर्दछ  
   - सर्भर-देखि-क्लाइन्ट स्ट्रिमिङको लागि वैकल्पिक सर्भर-सेन्ट इभेन्ट्स (SSE)  
   - नेटवर्कहरूमा टाढाको सर्भर संचार सक्षम बनाउँछ  
   - मानक HTTP प्रमाणीकरण (बेयरर टोकन, API कुञ्जीहरू, अनुकूल हेडरहरू) समर्थन गर्दछ  
   - सुरक्षित टोकन-आधारित प्रमाणीकरणको लागि MCP ले OAuth सिफारिस गर्दछ  

#### ट्रान्सपोर्ट अमूर्तता:

ट्रान्सपोर्ट लेयरले सबै ट्रान्सपोर्ट संयन्त्रहरूमा समान JSON-RPC 2.0 सन्देश ढाँचालाई सक्षम पार्दै डाटा तहबाट संचार विवरणहरूलाई अमूर्त बनाउँछ। यस अमूर्तताले अनुप्रयोगहरूलाई स्थानीय र टाढाको सर्भरहरू बीच सहज रूपमा स्विच गर्न अनुमति दिन्छ।  

### सुरक्षा विचारहरू

MCP कार्यान्वयनहरूले सबै प्रोटोकल अपरेसनहरूमा सुरक्षित, भरपर्दो, र सुरक्षित अन्तरक्रियाहरू सुनिश्चित गर्न धेरै महत्त्वपूर्ण सुरक्षा सिद्धान्तहरू पालना गर्नुपर्छ:

- **प्रयोगकर्ता सहमति र नियन्त्रण**: कुनै पनि डाटा पहुँच गर्नु अघि वा अपरेसनहरू प्रदर्शन गर्नु अघि प्रयोगकर्ताहरूले स्पष्ट सहमति प्रदान गर्नुपर्छ। उनीहरूले कुन डाटा साझा गरिन्छ र कुन कार्यहरू स्वीकृत छन् भन्ने स्पष्ट नियन्त्रण गर्नुपर्छ, गतिविधिहरू समीक्षा र स्वीकृत गर्न सहज प्रयोगकर्ता इन्टरफेसद्वारा समर्थित।  

- **डाटा गोपनीयता**: प्रयोगकर्ताको डाटा स्पष्ट सहमति बिना मात्र खुलासा गरिनुपर्छ र उपयुक्त पहुँच नियन्त्रणद्वारा सुरक्षित गरिनुपर्छ। MCP कार्यान्वयनहरूले अनधिकृत डाटा प्रसारणको विरुद्ध सुरक्षा गर्नुपर्छ र सबै अन्तरक्रियाहरूमा गोपनीयता कायम गर्नुपर्छ।  

- **उपकरण सुरक्षा**: कुनै पनि उपकरण प्रयोग गर्नु अघि स्पष्ट प्रयोगकर्ता सहमति आवश्यक छ। प्रयोगकर्ताहरूले प्रत्येक उपकरणको कार्यक्षमताको स्पष्ट समझ राख्नुपर्छ, र अनपेक्षित वा असुरक्षित उपकरण कार्यान्वयन रोक्न बलियो सुरक्षा सीमाहरू लागू गरिनुपर्छ।  

यी सुरक्षा सिद्धान्तहरू पालना गरेर, MCP ले प्रयोगकर्ताको विश्वास, गोपनीयता, र सुरक्षा सुनिश्चित गर्दछ, जबकि शक्तिशाली AI एकीकरणहरू सक्षम बनाउँछ।  

## कोड उदाहरणहरू: मुख्य घटकहरू

तल लोकप्रिय प्रोग्रामिङ भाषाहरूमा कोड उदाहरणहरू छन् जसले मुख्य MCP सर्भर घटकहरू र उपकरणहरू कार्यान्वयन गर्ने तरिका देखाउँछन्।  

### .NET उदाहरण: उपकरणहरूसँग साधारण MCP सर्भर सिर्जना गर्नुहोस्

तलको .NET कोड उदाहरणले कसरी साधारण MCP सर्भर कार्यान्वयन गर्ने, अनुकूल उपकरणहरू परिभाषित र दर्ता गर्ने, अनुरोधहरू ह्यान्डल गर्ने, र मोडल कन्टेक्स्ट प्रोटोकल प्रयोग गरेर सर्भर जडान गर्ने देखाउँछ।  

```csharp
using System;
using System.Threading.Tasks;
using ModelContextProtocol.Server;
using ModelContextProtocol.Server.Transport;
using ModelContextProtocol.Server.Tools;

public class WeatherServer
{
    public static async Task Main(string[] args)
    {
        // Create an MCP server
        var server = new McpServer(
            name: "Weather MCP Server",
            version: "1.0.0"
        );
        
        // Register our custom weather tool
        server.AddTool<string, WeatherData>("weatherTool", 
            description: "Gets current weather for a location",
            execute: async (location) => {
                // Call weather API (simplified)
                var weatherData = await GetWeatherDataAsync(location);
                return weatherData;
            });
        
        // Connect the server using stdio transport
        var transport = new StdioServerTransport();
        await server.ConnectAsync(transport);
        
        Console.WriteLine("Weather MCP Server started");
        
        // Keep the server running until process is terminated
        await Task.Delay(-1);
    }
    
    private static async Task<WeatherData> GetWeatherDataAsync(string location)
    {
        // This would normally call a weather API
        // Simplified for demonstration
        await Task.Delay(100); // Simulate API call
        return new WeatherData { 
            Temperature = 72.5,
            Conditions = "Sunny",
            Location = location
        };
    }
}

public class WeatherData
{
    public double Temperature { get; set; }
    public string Conditions { get; set; }
    public string Location { get; set; }
}
```  

### जाभा उदाहरण: MCP सर्भर घटकहरू

यो उदाहरणले माथिको .NET उदाहरणमा जस्तै MCP सर्भर र उपकरण दर्ता प्रदर्शन गर्दछ, तर जाभामा कार्यान्वयन गरिएको छ।  

```java
import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpToolDefinition;
import io.modelcontextprotocol.server.transport.StdioServerTransport;
import io.modelcontextprotocol.server.tool.ToolExecutionContext;
import io.modelcontextprotocol.server.tool.ToolResponse;

public class WeatherMcpServer {
    public static void main(String[] args) throws Exception {
        // Create an MCP server
        McpServer server = McpServer.builder()
            .name("Weather MCP Server")
            .version("1.0.0")
            .build();
            
        // Register a weather tool
        server.registerTool(McpToolDefinition.builder("weatherTool")
            .description("Gets current weather for a location")
            .parameter("location", String.class)
            .execute((ToolExecutionContext ctx) -> {
                String location = ctx.getParameter("location", String.class);
                
                // Get weather data (simplified)
                WeatherData data = getWeatherData(location);
                
                // Return formatted response
                return ToolResponse.content(
                    String.format("Temperature: %.1f°F, Conditions: %s, Location: %s", 
                    data.getTemperature(), 
                    data.getConditions(), 
                    data.getLocation())
                );
            })
            .build());
        
        // Connect the server using stdio transport
        try (StdioServerTransport transport = new StdioServerTransport()) {
            server.connect(transport);
            System.out.println("Weather MCP Server started");
            // Keep server running until process is terminated
            Thread.currentThread().join();
        }
    }
    
    private static WeatherData getWeatherData(String location) {
        // Implementation would call a weather API
        // Simplified for example purposes
        return new WeatherData(72.5, "Sunny", location);
    }
}

class WeatherData {
    private double temperature;
    private String conditions;
    private String location;
    
    public WeatherData(double temperature, String conditions, String location) {
        this.temperature = temperature;
        this.conditions = conditions;
        this.location = location;
    }
    
    public double getTemperature() {
        return temperature;
    }
    
    public String getConditions() {
        return conditions;
    }
    
    public String getLocation() {
        return location;
    }
}
```  

### पाइथन उदाहरण: MCP सर्भर निर्माण

यो उदाहरणले fastmcp प्रयोग गर्दछ, त्यसैले कृपया पहिले यसलाई स्थापना गर्नुहोस्:  

```python
pip install fastmcp
```  
कोड नमूना:  

```python
#!/usr/bin/env python3
import asyncio
from fastmcp import FastMCP
from fastmcp.transports.stdio import serve_stdio

# Create a FastMCP server
mcp = FastMCP(
    name="Weather MCP Server",
    version="1.0.0"
)

@mcp.tool()
def get_weather(location: str) -> dict:
    """Gets current weather for a location."""
    return {
        "temperature": 72.5,
        "conditions": "Sunny",
        "location": location
    }

# Alternative approach using a class
class WeatherTools:
    @mcp.tool()
    def forecast(self, location: str, days: int = 1) -> dict:
        """Gets weather forecast for a location for the specified number of days."""
        return {
            "location": location,
            "forecast": [
                {"day": i+1, "temperature": 70 + i, "conditions": "Partly Cloudy"}
                for i in range(days)
            ]
        }

# Register class tools
weather_tools = WeatherTools()

# Start the server
if __name__ == "__main__":
    asyncio.run(serve_stdio(mcp))
```  

### जाभास्क्रिप्ट उदाहरण: MCP सर्भर सिर्जना गर्नुहोस्

यो उदाहरणले जाभास्क्रिप्टमा MCP सर्भर सिर्जना गर्ने र दुई मौसमसम्बन्धी उपकरणहरू कसरी दर्ता गर्ने देखाउँछ।  

```javascript
// Using the official Model Context Protocol SDK
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod"; // For parameter validation

// Create an MCP server
const server = new McpServer({
  name: "Weather MCP Server",
  version: "1.0.0"
});

// Define a weather tool
server.tool(
  "weatherTool",
  {
    location: z.string().describe("The location to get weather for")
  },
  async ({ location }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const weatherData = await getWeatherData(location);
    
    return {
      content: [
        { 
          type: "text", 
          text: `Temperature: ${weatherData.temperature}°F, Conditions: ${weatherData.conditions}, Location: ${weatherData.location}` 
        }
      ]
    };
  }
);

// Define a forecast tool
server.tool(
  "forecastTool",
  {
    location: z.string(),
    days: z.number().default(3).describe("Number of days for forecast")
  },
  async ({ location, days }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const forecast = await getForecastData(location, days);
    
    return {
      content: [
        { 
          type: "text", 
          text: `${days}-day forecast for ${location}: ${JSON.stringify(forecast)}` 
        }
      ]
    };
  }
);

// Helper functions
async function getWeatherData(location) {
  // Simulate API call
  return {
    temperature: 72.5,
    conditions: "Sunny",
    location: location
  };
}

async function getForecastData(location, days) {
  // Simulate API call
  return Array.from({ length: days }, (_, i) => ({
    day: i + 1,
    temperature: 70 + Math.floor(Math.random() * 10),
    conditions: i % 2 === 0 ? "Sunny" : "Partly Cloudy"
  }));
}

// Connect the server using stdio transport
const transport = new StdioServerTransport();
server.connect(transport).catch(console.error);

console.log("Weather MCP Server started");
```  

यो जाभास्क्रिप्ट उदाहरणले कसरी MCP क्लाइन्ट सिर्जना गर्ने, सर्भरसँग जडान गर्ने, प्रम्प्ट पठाउने, र कुनै पनि उपकरण कलहरू सहित प्रतिक्रिया प्रक्रिया गर्ने देखाउँछ।  

## सुरक्षा र प्राधिकरण

MCP ले प्रोटोकलभरि सुरक्षा र प्राधिकरण व्यवस्थापन गर्न धेरै बिल्ट-इन अवधारणाहरू र संयन्त्रहरू समावेश गर्दछ:  

1. **उपकरण अनुमति नियन्त्रण**:  
   क्लाइन्टहरूले सत्रको समयमा मोडेललाई कुन उपकरणहरू प्रयोग गर्न अनुमति छ भनेर निर्दिष्ट गर्न सक्छन्। यसले स्पष्ट रूपमा स्वीकृत उपकरणहरू मात्र पहुँचयोग्य सुनिश्चित गर्दछ, अनपेक्षित वा असुरक्षित अपरेसनहरूको जोखिम कम गर्दछ। अनुमति प्रयोगकर्ता प्राथमिकताहरू, संगठनात्मक नीतिहरू, वा अन्तरक्रियाको सन्दर्भको आधारमा गतिशील रूपमा कन्फिगर गर्न सकिन्छ।  

2. **प्रमाणीकरण**:  
   सर्भरहरूले उपकरणहरू, स्रोतहरू, वा संवेदनशील अपरेसनहरूमा पहुँच प्रदान गर्नु अघि प्रमाणीकरण आवश्यक हुन सक्छ। यसमा API कुञ्जीहरू, OAuth टोकनहरू, वा अन्य प्रमाणीकरण योजनाहरू समावेश हुन सक्छ। उचित प्रमाणीकरणले मात्र विश्वासपात्र क्लाइन्ट र प्रयोगकर्ताहरूले सर्भर-साइड क्षमताहरू प्रयोग गर्न सक्छन् भन्ने सुनिश्चित गर्दछ।  

3. **मान्यता**:  
   सबै उपकरण कार्यान्वयनहरूको लागि प्यारामिटर मान्यता लागू गरिन्छ। प्रत्येक उपकरणले यसको प्यारामिटरहरूको अपेक्षित प्रकार, ढाँचा, र बाधाहरू परिभाषित गर्दछ, र सर्भरले आउने अनुरोधहरूलाई तदनुसार मान्यता दिन्छ। यसले खराब वा दुर्भावनापूर्ण इनपुटलाई उपकरण कार्यान्वयनसम्म पुग्नबाट रोक्छ र अपरेसनहरूको अखण्डता कायम राख्न मद्दत गर्दछ।  

4. **दर सीमितता**:  
   दुरुपयोग रोक्न र सर्भर स्रोतहरूको निष्पक्ष प्रयोग सुनिश्चित गर्न, MCP सर्भरहरूले उपकरण कलहरू र स्रोत पहुँचको लागि दर सीमितता कार्यान्वयन गर्न सक्छन्। दर सीमाहरू प्रति प्रयोगकर्ता, प्रति सत्र, वा विश्वव्यापी रूपमा लागू गर्न सकिन्छ, र सेवा अस्वीकार आक्रमणहरू वा अत्यधिक स्रोत खपतको विरुद्ध सुरक्षा गर्न मद्दत गर्दछ।  

यी संयन्त्रहरूलाई संयोजन गरेर, MCP ले भाषा मोडेलहरूलाई बाह्य उपकरणहरू र डाटा स्रोतहरूसँग एकीकृत गर्न सुरक्षित आधार प्रदान गर्दछ, जबकि पहुँच र प्रयोगमा प्रयोगकर्ता र विकासकर्ताहरूलाई सूक्ष्म नियन्त्रण दिन्छ।  

## प्रोटोकल सन्देशहरू र संचार प्रवाह

MCP संचारले होस्टहरू, क्लाइन्टहरू, र सर्भरहरू बीच स्पष्ट र भरपर्दो अन्तरक्रियाहरूलाई सहज बनाउन संरचित **JSON-RPC 2.0** सन्देशहरू प्रयोग गर्दछ। प्रोटोकलले विभिन्न प्रकारका अपरेसनहरूको लागि विशिष्ट सन्देश ढाँचाहरू परिभाषित गर्दछ:  

### मुख्य सन्देश प्रकारहरू:

#### **आरम्भ सन्देशहरू**  
- **`initialize` अनुरोध**: जडान स्थापना गर्दछ र प्रोटोकल संस्करण र क्षमताहरू वार्ता गर्दछ  
- **`initialize` प्रतिक्रिया**: समर्थित सुविधाहरू र सर्भर जानकारी पुष्टि गर्दछ  
- **`notifications/initialized`**: आरम्भ पूरा भएको र सत्र तयार भएको संकेत गर्दछ  

#### **पत्ता लगाउने सन्देशहरू**  
- **`tools/list` अनुरोध**: सर्भरबाट उपलब्ध उपकरणहरू पत्ता लगाउँछ  
- **`resources/list` अनुरोध**: उपलब्ध स्रोतहरू (डाटा स्रोतहरू) सूचीबद्ध गर्दछ  
- **`prompts/list` अनुरोध**: उपलब्ध प्रम्प्ट टेम्प्लेटहरू पुनःप्राप्त गर्दछ  

#### **कार्यान्वयन सन्देशहरू**  
- **`tools/call` अनुरोध**: प्रदान गरिएका प्यारामिटरहरूसँग विशिष्ट उपकरण कार्यान्वयन गर्दछ  
- **`resources/read` अनुरोध**: विशिष्ट स्रोतबाट सामग्री पुनःप्राप्त गर्दछ  
- **`prompts/get` अनुरोध**: वैकल्पिक प्यारामिटरहरूसँग प्रम्प्ट टेम्प्लेट पुनःप्राप्त गर्दछ  

#### **क्लाइन्ट-साइड सन्देशहरू**  
- **`sampling/complete` अनुरोध**: सर्भरले क्लाइन्टबाट LLM कम्प्लिसन अनुरोध गर्दछ  
- **`elicitation/request`**: सर्भरले क्लाइन्ट इन्टरफेस मार्फत प्रयोगकर्ताको इनपुट अनुरोध गर्दछ  
- **लग सन्देशहरू**: सर्भरले क्लाइन्टलाई संरचित लग सन्देशहरू पठाउँछ  

#### **सूचना सन्देशहरू**  
- **`notifications/tools/list_changed`**: सर्भरले उपकरण परिवर्तनहरूको बारेमा क्लाइन्टलाई सूचित गर्दछ  
- **`notifications/resources/list_changed`**: सर्भरले स्रोत परिवर्तनहरूको बारेमा क्लाइन्टलाई सूचित गर्दछ  
- **`notifications/prompts/list_changed`**: सर्भरले प्रम्प्ट परिवर्तनहरूको बारेमा क्लाइन्टलाई सूचित गर्दछ  

### सन्देश संरचना:

सबै MCP सन्देशहरूले JSON-RPC 2.0 ढाँचा पालना गर्छन्:  
- **अनुरोध सन्देशहरू**: `id`, `method`, र वैकल्पिक `params` समावेश गर्दछ  
- **प्रतिक्रिया सन्देशहरू**: `id` र `result` वा `error` समावेश गर्दछ  
- **सूचना सन्देशहरू**: `method` र वैकल्पिक `params` समावेश गर्दछ (कुनै `id` वा प्रतिक्रिया अपेक्षित छैन)  

यो संरचित संचारले भरपर्दो, ट्रेसयोग्य, र विस्तारयोग्य अन्तरक्रियाहरू सुनिश्चित गर्दछ, जसले वास्तविक-समय अपडेटहरू, उपकरण चेनिङ, र बलियो त्रुटि ह्यान्डलिङ जस्ता उन्नत परिदृश्यहरूलाई समर्थन गर्दछ।  

## मुख्य निष्कर्षहरू

- **आर्किटेक्चर**: MCP ले क्लाइन्ट-सर्भर आर्किटेक्चर प्रयोग गर्दछ जहाँ होस्टहरूले सर्भरहरूसँग धेरै क्लाइन्ट जडानहरू व्यवस्थापन गर्छन्  
- **सहभागीहरू**: इकोसिस्टममा होस्टहरू (AI अनुप्रयोगहरू), क्लाइन्टहरू (प्रोटोकल कनेक्टरहरू), र सर्भरहरू (क्षमता प्रदायकहरू) समावेश छन्  
- **ट्रान्सपोर्ट संयन्त्रहरू**: संचार STDIO (स्थानीय) र स्ट्रीमेबल HTTP वैकल्पिक SSE (टाढाको) समर्थन गर्दछ  
- **मुख्य प्रिमिटिभहरू**: सर्भरहरूले उपकरणहरू (कार्यान्वयन योग्य कार्यहरू), स्रोतहरू (डाटा स्रोतहरू), र प्रम्प्टहरू (टेम्प्लेटहरू) उजागर गर्छन्  
- **क्लाइन्ट प्रिमिटिभहरू**: सर्भरहरूले क्लाइन्टहरूबाट नमूना (LLM कम्प्लिसन), इनपुट प्राप्ति (प्रयोगकर्ता इनपुट), र लगिङ अनुरोध गर्न सक्छन्  
- **प्रोटोकल आधार**: JSON-RPC 2.0 मा निर्मित मिति-आधारित संस्करण (हाल: 2025-06-18)  
- **रियल-टाइम क्षमताहरू**: गतिशील अपडेटहरू र वास्तविक-समय समक्रमणको लागि सूचनाहरू समर्थन गर्दछ  
- **सुरक्षा पहिलो**: स्पष्ट प्रयोगकर्ता सहमति, डाटा गोपनीयता संरक्षण, र सुरक्षित ट्रान्सपोर्ट कोर आवश्यकताहरू हुन्  

## अभ्यास

तपाईंको क्षेत्रमा उपयोगी हुने साधारण MCP उपकरण डिजाइन गर्नुहोस्। परिभाषित गर्नुहोस्:  
1. उपकरणको नाम के हुनेछ  
2. यसले कुन प्यारामिटरहरू स्वीकार गर्नेछ  
3. यसले के आउटपुट फर्काउनेछ  
4. मोडेलले प्रयोगकर्ताको समस्याहरू समाधान गर्न यो उपकरण कसरी प्रयोग गर्न सक्छ  

---

## अब के गर्ने

अर्को: [अध्याय २: सुरक्षा](../02-Security/README.md)  

---

**अस्वीकरण**:  
यो दस्तावेज़ AI अनुवाद सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) प्रयोग गरी अनुवाद गरिएको हो। हामी यथासम्भव सटीकता सुनिश्चित गर्न प्रयास गर्छौं, तर कृपया ध्यान दिनुहोस् कि स्वचालित अनुवादहरूमा त्रुटि वा अशुद्धता हुन सक्छ। यसको मूल भाषामा रहेको मूल दस्तावेज़लाई आधिकारिक स्रोत मानिनुपर्छ। महत्त्वपूर्ण जानकारीका लागि, व्यावसायिक मानव अनुवाद सिफारिस गरिन्छ। यस अनुवादको प्रयोगबाट उत्पन्न हुने कुनै पनि गलतफहमी वा गलत व्याख्याको लागि हामी जिम्मेवार हुने छैनौं।