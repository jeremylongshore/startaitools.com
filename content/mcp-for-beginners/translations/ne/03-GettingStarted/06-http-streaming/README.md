<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "5f1383103523fa822e1fec7ef81904d5",
  "translation_date": "2025-08-18T16:16:43+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "ne"
}
-->
# HTTPS स्ट्रिमिङ्गसँग मोडेल कन्टेक्स्ट प्रोटोकल (MCP)

यो अध्यायले HTTPS प्रयोग गरेर सुरक्षित, स्केलेबल, र वास्तविक-समय स्ट्रिमिङ्गको लागि मोडेल कन्टेक्स्ट प्रोटोकल (MCP) कार्यान्वयन गर्ने विस्तृत मार्गदर्शन प्रदान गर्दछ। यसमा स्ट्रिमिङ्गको उद्देश्य, उपलब्ध ट्रान्सपोर्ट मेकानिज्महरू, MCP मा स्ट्रिमेबल HTTP कसरी कार्यान्वयन गर्ने, सुरक्षा सम्बन्धी उत्कृष्ट अभ्यासहरू, SSE बाट माइग्रेशन, र आफ्नै स्ट्रिमिङ्ग MCP एप्लिकेसनहरू निर्माण गर्ने व्यावहारिक मार्गदर्शन समावेश छ।

## MCP मा ट्रान्सपोर्ट मेकानिज्म र स्ट्रिमिङ्ग

यस खण्डले MCP मा उपलब्ध विभिन्न ट्रान्सपोर्ट मेकानिज्महरू र क्लाइन्ट र सर्भर बीच वास्तविक-समय सञ्चार सक्षम गर्न तिनीहरूको भूमिकाको अन्वेषण गर्दछ।

### ट्रान्सपोर्ट मेकानिज्म भनेको के हो?

ट्रान्सपोर्ट मेकानिज्मले क्लाइन्ट र सर्भर बीच डेटा कसरी आदानप्रदान गरिन्छ भन्ने परिभाषित गर्दछ। MCP ले विभिन्न वातावरण र आवश्यकताहरूलाई अनुकूल बनाउन धेरै प्रकारका ट्रान्सपोर्ट प्रकारहरू समर्थन गर्दछ:

- **stdio**: स्थानीय र CLI-आधारित उपकरणहरूको लागि उपयुक्त मानक इनपुट/आउटपुट। सरल तर वेब वा क्लाउडको लागि उपयुक्त छैन।
- **SSE (सर्भर-सेन्ट इभेन्ट्स)**: सर्भरले HTTP मार्फत क्लाइन्टहरूलाई वास्तविक-समय अपडेटहरू पठाउन अनुमति दिन्छ। वेब UI को लागि राम्रो, तर स्केलेबिलिटी र लचिलोपनमा सीमित।
- **स्ट्रिमेबल HTTP**: आधुनिक HTTP-आधारित स्ट्रिमिङ्ग ट्रान्सपोर्ट, जसले सूचनाहरू र राम्रो स्केलेबिलिटीलाई समर्थन गर्दछ। अधिकांश उत्पादन र क्लाउड परिदृश्यहरूको लागि सिफारिस गरिन्छ।

### तुलना तालिका

तलको तुलना तालिकामा यी ट्रान्सपोर्ट मेकानिज्महरूको भिन्नताहरू बुझ्न सकिन्छ:

| ट्रान्सपोर्ट         | वास्तविक-समय अपडेट | स्ट्रिमिङ्ग | स्केलेबिलिटी | प्रयोग केस                |
|-------------------|------------------|-----------|-------------|-------------------------|
| stdio             | छैन               | छैन        | कम         | स्थानीय CLI उपकरणहरू         |
| SSE               | छ              | छ       | मध्यम      | वेब, वास्तविक-समय अपडेट  |
| स्ट्रिमेबल HTTP   | छ              | छ       | उच्च        | क्लाउड, बहु-क्लाइन्ट     |

> **TIP:** सही ट्रान्सपोर्टको छनोटले प्रदर्शन, स्केलेबिलिटी, र प्रयोगकर्ता अनुभवलाई प्रभाव पार्छ। **स्ट्रिमेबल HTTP** आधुनिक, स्केलेबल, र क्लाउड-रेडी एप्लिकेसनहरूको लागि सिफारिस गरिन्छ।

पछिल्ला अध्यायहरूमा तपाईंले stdio र SSE ट्रान्सपोर्टहरू देख्नुभयो, र यस अध्यायमा स्ट्रिमेबल HTTP ट्रान्सपोर्ट समेटिएको छ।

## स्ट्रिमिङ्ग: अवधारणा र उद्देश्य

स्ट्रिमिङ्गको आधारभूत अवधारणा र उद्देश्यहरू बुझ्नु प्रभावकारी वास्तविक-समय सञ्चार प्रणाली कार्यान्वयन गर्न महत्त्वपूर्ण छ।

**स्ट्रिमिङ्ग** नेटवर्क प्रोग्रामिङ्गको एउटा प्रविधि हो जसले डेटा सम्पूर्ण प्रतिक्रिया तयार नभएसम्म पर्खनुको सट्टा साना, व्यवस्थापन गर्न मिल्ने टुक्राहरू वा घटनाहरूको रूपमा पठाउन र प्राप्त गर्न अनुमति दिन्छ। यो विशेष गरी उपयोगी छ:

- ठूला फाइलहरू वा डेटासेटहरू।
- वास्तविक-समय अपडेटहरू (जस्तै, च्याट, प्रगति बारहरू)।
- लामो समय लाग्ने गणनाहरू जहाँ प्रयोगकर्तालाई सूचित राख्न चाहिन्छ।

स्ट्रिमिङ्गको उच्च-स्तरीय जानकारी:

- डेटा क्रमिक रूपमा डेलिभर गरिन्छ, सबै एकैचोटि होइन।
- क्लाइन्टले डेटा आइपुग्ने बित्तिकै प्रशोधन गर्न सक्छ।
- प्रतीत हुने विलम्बता घटाउँछ र प्रयोगकर्ता अनुभव सुधार गर्दछ।

### किन स्ट्रिमिङ्ग प्रयोग गर्ने?

स्ट्रिमिङ्ग प्रयोग गर्ने कारणहरू निम्न छन्:

- प्रयोगकर्ताहरूले अन्त्यमा मात्र होइन, तुरुन्तै प्रतिक्रिया पाउँछन्।
- वास्तविक-समय एप्लिकेसनहरू र उत्तरदायी UI सक्षम गर्दछ।
- नेटवर्क र कम्प्युट स्रोतहरूको अधिक कुशल प्रयोग।

### साधारण उदाहरण: HTTP स्ट्रिमिङ्ग सर्भर र क्लाइन्ट

स्ट्रिमिङ्ग कसरी कार्यान्वयन गर्न सकिन्छ भन्ने एउटा साधारण उदाहरण यहाँ छ:

#### Python

**सर्भर (Python, FastAPI र StreamingResponse प्रयोग गरेर):**

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

**क्लाइन्ट (Python, requests प्रयोग गरेर):**

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

यो उदाहरणले सर्भरले सबै सन्देशहरू तयार नभएसम्म पर्खनुको सट्टा उपलब्ध भएजति सन्देशहरू क्लाइन्टलाई पठाउने तरिका प्रदर्शन गर्दछ।

**यो कसरी काम गर्छ:**

- सर्भरले प्रत्येक सन्देश तयार भएजति पठाउँछ।
- क्लाइन्टले प्रत्येक टुक्रा आइपुग्ने बित्तिकै प्राप्त र प्रिन्ट गर्छ।

**आवश्यकताहरू:**

- सर्भरले स्ट्रिमिङ्ग प्रतिक्रिया (जस्तै, FastAPI मा `StreamingResponse`) प्रयोग गर्नुपर्छ।
- क्लाइन्टले प्रतिक्रिया स्ट्रिमको रूपमा प्रशोधन गर्नुपर्छ (`stream=True` requests मा)।
- सामग्री प्रकार सामान्यतया `text/event-stream` वा `application/octet-stream` हुन्छ।

#### Java

**सर्भर (Java, Spring Boot र Server-Sent Events प्रयोग गरेर):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**क्लाइन्ट (Java, Spring WebFlux WebClient प्रयोग गरेर):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Java कार्यान्वयन नोटहरू:**

- Spring Boot को reactive stack `Flux` को साथ स्ट्रिमिङ्गको लागि प्रयोग गरिएको छ।
- `ServerSentEvent` ले इभेन्ट प्रकारहरूसँग संरचित इभेन्ट स्ट्रिमिङ्ग प्रदान गर्दछ।
- `WebClient` को `bodyToFlux()` ले reactive स्ट्रिमिङ्ग उपभोग सक्षम गर्दछ।
- `delayElements()` ले इभेन्टहरू बीचको प्रशोधन समय अनुकरण गर्दछ।
- इभेन्टहरूमा राम्रो क्लाइन्ट ह्यान्डलिङ्गको लागि प्रकारहरू (`info`, `result`) हुन सक्छ।

### तुलना: क्लासिक स्ट्रिमिङ्ग बनाम MCP स्ट्रिमिङ्ग

क्लासिक तरिकामा स्ट्रिमिङ्ग कसरी काम गर्छ र MCP मा कसरी काम गर्छ भन्ने भिन्नताहरू यसरी देखाउन सकिन्छ:

| विशेषता                | क्लासिक HTTP स्ट्रिमिङ्ग         | MCP स्ट्रिमिङ्ग (सूचनाहरू)      |
|------------------------|-------------------------------|-------------------------------------|
| मुख्य प्रतिक्रिया          | टुक्रामा                       | अन्त्यमा एकल                      |
| प्रगति अपडेटहरू       | डेटा टुक्राहरूको रूपमा पठाइन्छ           | सूचनाहरूको रूपमा पठाइन्छ               |
| क्लाइन्ट आवश्यकताहरू    | स्ट्रिम प्रशोधन गर्नुपर्छ           | सन्देश ह्यान्डलर कार्यान्वयन गर्नुपर्छ      |
| प्रयोग केस               | ठूला फाइलहरू, AI टोकन स्ट्रिमहरू | प्रगति, लगहरू, वास्तविक-समय प्रतिक्रिया  |

### देखिएका मुख्य भिन्नताहरू

थप रूपमा, यहाँ केही मुख्य भिन्नताहरू छन्:

- **सञ्चार ढाँचा:**
  - क्लासिक HTTP स्ट्रिमिङ्ग: डेटा टुक्राहरू पठाउन सरल chunked ट्रान्सफर इन्कोडिङ्ग प्रयोग गर्दछ।
  - MCP स्ट्रिमिङ्ग: JSON-RPC प्रोटोकलको साथ संरचित सूचना प्रणाली प्रयोग गर्दछ।

- **सन्देश ढाँचा:**
  - क्लासिक HTTP: नयाँ लाइनहरूसँग सादा पाठ टुक्राहरू।
  - MCP: मेटाडेटासहितको संरचित LoggingMessageNotification वस्तुहरू।

- **क्लाइन्ट कार्यान्वयन:**
  - क्लासिक HTTP: स्ट्रिमिङ्ग प्रतिक्रियाहरू प्रशोधन गर्ने सरल क्लाइन्ट।
  - MCP: विभिन्न प्रकारका सन्देशहरू प्रशोधन गर्न सन्देश ह्यान्डलर भएको परिष्कृत क्लाइन्ट।

- **प्रगति अपडेटहरू:**
  - क्लासिक HTTP: प्रगति मुख्य प्रतिक्रिया स्ट्रिमको भाग हो।
  - MCP: प्रगति मुख्य प्रतिक्रियाको अन्त्यमा आउँदा छुट्टै सूचना सन्देशहरू मार्फत पठाइन्छ।

### सिफारिसहरू

क्लासिक स्ट्रिमिङ्ग (जस्तै, `/stream` अन्तर्क्रियात्मक बिन्दु) कार्यान्वयन गर्ने बनाम MCP मार्फत स्ट्रिमिङ्ग छनोट गर्दा केही सिफारिसहरू छन्:

- **सरल स्ट्रिमिङ्ग आवश्यकताहरूको लागि:** क्लासिक HTTP स्ट्रिमिङ्ग कार्यान्वयन गर्न सजिलो छ र आधारभूत स्ट्रिमिङ्ग आवश्यकताहरूको लागि पर्याप्त छ।
- **जटिल, अन्तरक्रियात्मक एप्लिकेसनहरूको लागि:** MCP स्ट्रिमिङ्गले सूचनाहरू र अन्तिम परिणामहरू बीचको छुट्टै संरचना र धनी मेटाडेटासहितको दृष्टिकोण प्रदान गर्दछ।
- **AI एप्लिकेसनहरूको लागि:** लामो समय लाग्ने AI कार्यहरूको लागि MCP को सूचना प्रणाली विशेष रूपमा उपयोगी छ, जहाँ प्रयोगकर्ताहरूलाई प्रगतिको जानकारी दिन चाहिन्छ।
SSE बाट Streamable HTTP मा अपग्रेड गर्न दुई प्रमुख कारणहरू छन्:

- Streamable HTTP ले SSE भन्दा राम्रो स्केलेबिलिटी, अनुकूलता, र समृद्ध सूचना समर्थन प्रदान गर्दछ।  
- यो नयाँ MCP एप्लिकेसनहरूको लागि सिफारिस गरिएको ट्रान्सपोर्ट हो।  

### माइग्रेशन चरणहरू

यहाँ तपाईंको MCP एप्लिकेसनहरूमा SSE बाट Streamable HTTP मा माइग्रेट गर्ने तरिका छ:

- **सर्भर कोड अपडेट गर्नुहोस्** `mcp.run()` मा `transport="streamable-http"` प्रयोग गर्न।  
- **क्लाइन्ट कोड अपडेट गर्नुहोस्** SSE क्लाइन्टको सट्टा `streamablehttp_client` प्रयोग गर्न।  
- **क्लाइन्टमा सन्देश ह्यान्डलर कार्यान्वयन गर्नुहोस्** सूचनाहरू प्रशोधन गर्न।  
- **अस्तित्वमा रहेका उपकरण र वर्कफ्लोहरूसँग अनुकूलता परीक्षण गर्नुहोस्।**  

### अनुकूलता कायम राख्दै

माइग्रेशन प्रक्रियाको क्रममा SSE क्लाइन्टहरूसँग अनुकूलता कायम राख्न सिफारिस गरिन्छ। यहाँ केही रणनीतिहरू छन्:

- SSE र Streamable HTTP दुवैलाई फरक एन्डपोइन्टहरूमा चलाएर समर्थन गर्न सक्नुहुन्छ।  
- क्लाइन्टहरूलाई नयाँ ट्रान्सपोर्टमा क्रमिक रूपमा माइग्रेट गर्नुहोस्।  

### चुनौतीहरू

माइग्रेशनको क्रममा निम्न चुनौतीहरू समाधान गर्न सुनिश्चित गर्नुहोस्:

- सबै क्लाइन्टहरू अपडेट गरिएको सुनिश्चित गर्नु।  
- सूचना डेलिभरीमा हुने भिन्नताहरू व्यवस्थापन गर्नु।  

## सुरक्षा विचारहरू

HTTP-आधारित ट्रान्सपोर्टहरू जस्तै Streamable HTTP प्रयोग गर्दा, कुनै पनि सर्भर कार्यान्वयन गर्दा सुरक्षा उच्च प्राथमिकतामा राखिनुपर्छ।  

HTTP-आधारित ट्रान्सपोर्टहरूसँग MCP सर्भर कार्यान्वयन गर्दा, सुरक्षा एक प्रमुख चासो हो जसले धेरै आक्रमण भेक्टरहरू र सुरक्षा संयन्त्रहरूको सावधानीपूर्वक ध्यान दिन आवश्यक छ।  

### अवलोकन

HTTP मार्फत MCP सर्भरहरू सार्वजनिक गर्दा सुरक्षा महत्त्वपूर्ण हुन्छ। Streamable HTTP ले नयाँ आक्रमण सतहहरू प्रस्तुत गर्दछ र सावधानीपूर्वक कन्फिगरेसन आवश्यक छ।  

यहाँ केही प्रमुख सुरक्षा विचारहरू छन्:

- **Origin हेडर मान्यता**: DNS रिबाइन्डिङ आक्रमणहरू रोक्न `Origin` हेडर सधैं मान्यता गर्नुहोस्।  
- **Localhost बाइन्डिङ**: स्थानीय विकासको लागि, सर्भरहरूलाई `localhost` मा बाइन्ड गर्नुहोस् ताकि तिनीहरू सार्वजनिक इन्टरनेटमा नखुलून्।  
- **प्रमाणीकरण**: उत्पादन परिनियोजनहरूको लागि प्रमाणीकरण (जस्तै, API कुञ्जीहरू, OAuth) कार्यान्वयन गर्नुहोस्।  
- **CORS**: क्रस-ओरिजिन रिसोर्स सेयरिङ (CORS) नीतिहरू कन्फिगर गरेर पहुँच प्रतिबन्धित गर्नुहोस्।  
- **HTTPS**: ट्राफिक इन्क्रिप्ट गर्न उत्पादनमा HTTPS प्रयोग गर्नुहोस्।  

### उत्कृष्ट अभ्यासहरू

थप रूपमा, तपाईंको MCP स्ट्रिमिङ सर्भरमा सुरक्षा कार्यान्वयन गर्दा निम्न उत्कृष्ट अभ्यासहरू पालना गर्नुहोस्:

- मान्यता बिना आउने अनुरोधहरूमा कहिल्यै विश्वास नगर्नुहोस्।  
- सबै पहुँच र त्रुटिहरू लग गर्नुहोस् र अनुगमन गर्नुहोस्।  
- सुरक्षा कमजोरीहरूलाई पाट्न निर्भरता नियमित रूपमा अपडेट गर्नुहोस्।  

### चुनौतीहरू

MCP स्ट्रिमिङ सर्भरहरूमा सुरक्षा कार्यान्वयन गर्दा तपाईंले केही चुनौतीहरूको सामना गर्नुहुनेछ:

- विकासको सजिलोसँग सुरक्षा सन्तुलन गर्नु।  
- विभिन्न क्लाइन्ट वातावरणहरूसँग अनुकूलता सुनिश्चित गर्नु।  

### असाइनमेन्ट: आफ्नो स्ट्रिमिङ MCP एप बनाउनुहोस्

**परिदृश्य:**  
MCP सर्भर र क्लाइन्ट बनाउनुहोस् जहाँ सर्भरले वस्तुहरूको सूची (जस्तै, फाइलहरू वा कागजातहरू) प्रशोधन गर्छ र प्रशोधित प्रत्येक वस्तुको लागि सूचना पठाउँछ। क्लाइन्टले सूचना प्राप्त हुने बित्तिकै प्रदर्शन गर्नुपर्छ।  

**चरणहरू:**  

1. सूची प्रशोधन गर्ने र प्रत्येक वस्तुको लागि सूचना पठाउने सर्भर उपकरण कार्यान्वयन गर्नुहोस्।  
2. सूचनाहरू वास्तविक समयमा प्रदर्शन गर्न सन्देश ह्यान्डलरसहित क्लाइन्ट कार्यान्वयन गर्नुहोस्।  
3. सर्भर र क्लाइन्ट दुवै चलाएर तपाईंको कार्यान्वयन परीक्षण गर्नुहोस्, र सूचनाहरू अवलोकन गर्नुहोस्।  

[Solution](./solution/README.md)  

## थप अध्ययन र अब के गर्ने?

MCP स्ट्रिमिङसँग तपाईंको यात्रा जारी राख्न र तपाईंको ज्ञान विस्तार गर्न, यो खण्डले थप स्रोतहरू र उन्नत एप्लिकेसनहरू निर्माण गर्नका लागि सुझावहरू प्रदान गर्दछ।  

### थप अध्ययन

- [Microsoft: HTTP स्ट्रिमिङको परिचय](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)  
- [Microsoft: सर्भर-सेन्ट इभेन्ट्स (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)  
- [Microsoft: ASP.NET Core मा CORS](https://learn.microsoft.com/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)  
- [Python requests: स्ट्रिमिङ अनुरोधहरू](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)  

### अब के गर्ने?

- वास्तविक-समय विश्लेषण, च्याट, वा सहकार्यात्मक सम्पादनका लागि स्ट्रिमिङ प्रयोग गर्ने थप उन्नत MCP उपकरणहरू निर्माण प्रयास गर्नुहोस्।  
- प्रत्यक्ष UI अपडेटहरूको लागि MCP स्ट्रिमिङलाई फ्रन्टएन्ड फ्रेमवर्कहरूसँग (React, Vue, आदि) एकीकृत गर्ने अन्वेषण गर्नुहोस्।  
- अर्को: [VSCode को लागि AI टूलकिट प्रयोग गर्नुहोस्](../07-aitk/README.md)  

**अस्वीकरण**:  
यो दस्तावेज़ AI अनुवाद सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) प्रयोग गरेर अनुवाद गरिएको छ। हामी शुद्धताको लागि प्रयास गर्छौं, तर कृपया ध्यान दिनुहोस् कि स्वचालित अनुवादमा त्रुटिहरू वा अशुद्धताहरू हुन सक्छ। यसको मूल भाषा मा रहेको मूल दस्तावेज़लाई आधिकारिक स्रोत मानिनुपर्छ। महत्वपूर्ण जानकारीको लागि, व्यावसायिक मानव अनुवाद सिफारिस गरिन्छ। यस अनुवादको प्रयोगबाट उत्पन्न हुने कुनै पनि गलतफहमी वा गलत व्याख्याको लागि हामी जिम्मेवार हुने छैनौं।