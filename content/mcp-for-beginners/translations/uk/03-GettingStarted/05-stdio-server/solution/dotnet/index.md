<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "69372338676e01a2c97f42f70fdfbf42",
  "translation_date": "2025-08-26T20:27:05+00:00",
  "source_file": "03-GettingStarted/05-stdio-server/solution/dotnet/README.md",
  "language_code": "uk"
}
-->
# MCP stdio Server - .NET Рішення

> **⚠️ Важливо**: Це рішення було оновлено для використання **stdio транспорту**, як рекомендовано в MCP Специфікації 2025-06-18. Оригінальний SSE транспорт був застарілий.

## Огляд

Це .NET рішення демонструє, як створити MCP сервер, використовуючи актуальний stdio транспорт. Stdio транспорт є простішим, більш безпечним і забезпечує кращу продуктивність у порівнянні із застарілим SSE підходом.

## Попередні вимоги

- .NET 9.0 SDK або новіший
- Базове розуміння .NET dependency injection

## Інструкції з налаштування

### Крок 1: Відновлення залежностей

```bash
dotnet restore
```

### Крок 2: Збірка проєкту

```bash
dotnet build
```

## Запуск сервера

Stdio сервер працює інакше, ніж старий сервер на основі HTTP. Замість запуску веб-сервера він взаємодіє через stdin/stdout:

```bash
dotnet run
```

**Важливо**: Сервер може виглядати так, ніби він завис - це нормально! Він очікує JSON-RPC повідомлення через stdin.

## Тестування сервера

### Метод 1: Використання MCP Inspector (Рекомендовано)

```bash
npx @modelcontextprotocol/inspector dotnet run
```

Це дозволить:
1. Запустити ваш сервер як підпроцес
2. Відкрити веб-інтерфейс для тестування
3. Інтерактивно тестувати всі інструменти сервера

### Метод 2: Тестування через командний рядок

Ви також можете протестувати, запустивши Inspector напряму:

```bash
npx @modelcontextprotocol/inspector dotnet run --project .
```

### Доступні інструменти

Сервер надає такі інструменти:

- **AddNumbers(a, b)**: Додає два числа
- **MultiplyNumbers(a, b)**: Множить два числа  
- **GetGreeting(name)**: Генерує персоналізоване привітання
- **GetServerInfo()**: Отримує інформацію про сервер

### Тестування з Claude Desktop

Щоб використовувати цей сервер із Claude Desktop, додайте цю конфігурацію до вашого `claude_desktop_config.json`:

```json
{
  "mcpServers": {
    "example-stdio-server": {
      "command": "dotnet",
      "args": ["run", "--project", "path/to/server.csproj"]
    }
  }
}
```

## Структура проєкту

```
dotnet/
├── Program.cs           # Main server setup and configuration
├── Tools.cs            # Tool implementations
├── server.csproj       # Project file with dependencies
├── server.sln         # Solution file
├── Properties/         # Project properties
└── README.md          # This file
```

## Основні відмінності від HTTP/SSE

**Stdio транспорт (Актуальний):**
- ✅ Просте налаштування - не потрібен веб-сервер
- ✅ Краща безпека - немає HTTP кінцевих точок
- ✅ Використовує `Host.CreateApplicationBuilder()` замість `WebApplication.CreateBuilder()`
- ✅ `WithStdioTransport()` замість `WithHttpTransport()`
- ✅ Консольний додаток замість веб-додатку
- ✅ Краща продуктивність

**HTTP/SSE транспорт (Застарілий):**
- ❌ Потребував ASP.NET Core веб-сервер
- ❌ Потрібна була настройка маршрутизації `app.MapMcp()`
- ❌ Складніша конфігурація та залежності
- ❌ Додаткові міркування щодо безпеки
- ❌ Застарілий у MCP 2025-06-18

## Особливості розробки

- **Dependency Injection**: Повна підтримка DI для сервісів і логування
- **Структуроване логування**: Коректне логування в stderr за допомогою `ILogger<T>`
- **Атрибути інструментів**: Чисте визначення інструментів за допомогою атрибутів `[McpServerTool]`
- **Підтримка Async**: Усі інструменти підтримують асинхронні операції
- **Обробка помилок**: Акуратна обробка помилок і логування

## Поради для розробки

- Використовуйте `ILogger` для логування (ніколи не пишіть напряму в stdout)
- Збирайте проєкт за допомогою `dotnet build` перед тестуванням
- Тестуйте за допомогою Inspector для візуального налагодження
- Усе логування автоматично йде в stderr
- Сервер обробляє сигнали для коректного завершення роботи

Це рішення відповідає актуальній MCP специфікації і демонструє найкращі практики для реалізації stdio транспорту за допомогою .NET.

---

**Відмова від відповідальності**:  
Цей документ був перекладений за допомогою сервісу автоматичного перекладу [Co-op Translator](https://github.com/Azure/co-op-translator). Хоча ми прагнемо до точності, будь ласка, майте на увазі, що автоматичні переклади можуть містити помилки або неточності. Оригінальний документ на його рідній мові слід вважати авторитетним джерелом. Для критичної інформації рекомендується професійний людський переклад. Ми не несемо відповідальності за будь-які непорозуміння або неправильні тлумачення, що виникають внаслідок використання цього перекладу.