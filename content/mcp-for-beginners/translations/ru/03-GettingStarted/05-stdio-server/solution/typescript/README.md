<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "9d799c4a30a8383e0a74af9153262972",
  "translation_date": "2025-08-26T20:05:26+00:00",
  "source_file": "03-GettingStarted/05-stdio-server/solution/typescript/README.md",
  "language_code": "ru"
}
-->
# MCP stdio Server - Решение на TypeScript

> **⚠️ Важно**: Это решение было обновлено для использования транспорта **stdio**, как рекомендовано в спецификации MCP от 2025-06-18. Оригинальный транспорт SSE был устаревшим.

## Обзор

Это решение на TypeScript демонстрирует, как создать MCP сервер с использованием текущего транспорта stdio. Транспорт stdio проще, безопаснее и обеспечивает лучшую производительность по сравнению с устаревшим подходом SSE.

## Предварительные требования

- Node.js версии 18+ или выше
- Менеджер пакетов npm или yarn

## Инструкции по настройке

### Шаг 1: Установите зависимости

```bash
npm install
```

### Шаг 2: Соберите проект

```bash
npm run build
```

## Запуск сервера

Сервер stdio работает иначе, чем старый сервер SSE. Вместо запуска веб-сервера он взаимодействует через stdin/stdout:

```bash
npm start
```

**Важно**: Сервер может показаться зависшим — это нормально! Он ожидает JSON-RPC сообщения через stdin.

## Тестирование сервера

### Метод 1: Использование MCP Inspector (Рекомендуется)

```bash
npm run inspector
```

Это позволит:
1. Запустить ваш сервер как подпроцесс
2. Открыть веб-интерфейс для тестирования
3. Интерактивно протестировать все инструменты сервера

### Метод 2: Тестирование через командную строку

Вы также можете протестировать, запустив Inspector напрямую:

```bash
npx @modelcontextprotocol/inspector node build/index.js
```

### Доступные инструменты

Сервер предоставляет следующие инструменты:

- **add(a, b)**: Сложение двух чисел
- **multiply(a, b)**: Умножение двух чисел  
- **get_greeting(name)**: Генерация персонализированного приветствия
- **get_server_info()**: Получение информации о сервере

### Тестирование с Claude Desktop

Чтобы использовать этот сервер с Claude Desktop, добавьте следующую конфигурацию в ваш `claude_desktop_config.json`:

```json
{
  "mcpServers": {
    "example-stdio-server": {
      "command": "node",
      "args": ["path/to/build/index.js"]
    }
  }
}
```

## Структура проекта

```
typescript/
├── src/
│   └── index.ts          # Main server implementation
├── build/                # Compiled JavaScript (generated)
├── package.json          # Project configuration
├── tsconfig.json         # TypeScript configuration
└── README.md            # This file
```

## Основные отличия от SSE

**Транспорт stdio (Текущий):**
- ✅ Более простая настройка — не требуется HTTP сервер
- ✅ Лучшая безопасность — отсутствуют HTTP конечные точки
- ✅ Взаимодействие через подпроцессы
- ✅ JSON-RPC через stdin/stdout
- ✅ Лучшая производительность

**Транспорт SSE (Устаревший):**
- ❌ Требовалась настройка сервера Express
- ❌ Нужна была сложная маршрутизация и управление сессиями
- ❌ Больше зависимостей (Express, обработка HTTP)
- ❌ Дополнительные вопросы безопасности
- ❌ Устарел в MCP 2025-06-18

## Советы по разработке

- Используйте `console.error()` для логирования (никогда не используйте `console.log()`, так как он пишет в stdout)
- Собирайте проект с помощью `npm run build` перед тестированием
- Тестируйте с Inspector для визуальной отладки
- Убедитесь, что все JSON сообщения правильно отформатированы
- Сервер автоматически обрабатывает корректное завершение работы при SIGINT/SIGTERM

Это решение соответствует текущей спецификации MCP и демонстрирует лучшие практики для реализации транспорта stdio с использованием TypeScript.

---

**Отказ от ответственности**:  
Этот документ был переведен с помощью сервиса автоматического перевода [Co-op Translator](https://github.com/Azure/co-op-translator). Несмотря на наши усилия обеспечить точность, автоматические переводы могут содержать ошибки или неточности. Оригинальный документ на его исходном языке следует считать авторитетным источником. Для получения критически важной информации рекомендуется профессиональный перевод человеком. Мы не несем ответственности за любые недоразумения или неправильные интерпретации, возникшие в результате использования данного перевода.