<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "5f1383103523fa822e1fec7ef81904d5",
  "translation_date": "2025-08-18T16:52:02+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "pa"
}
-->
# HTTPS ਸਟ੍ਰੀਮਿੰਗ ਮਾਡਲ ਕਾਂਟੈਕਸਟ ਪ੍ਰੋਟੋਕੋਲ (MCP) ਨਾਲ

ਇਹ ਅਧਿਆਇ HTTPS ਦੀ ਵਰਤੋਂ ਕਰਕੇ ਮਾਡਲ ਕਾਂਟੈਕਸਟ ਪ੍ਰੋਟੋਕੋਲ (MCP) ਨਾਲ ਸੁਰੱਖਿਅਤ, ਸਕੇਲਬਲ ਅਤੇ ਰੀਅਲ-ਟਾਈਮ ਸਟ੍ਰੀਮਿੰਗ ਨੂੰ ਲਾਗੂ ਕਰਨ ਲਈ ਇੱਕ ਵਿਸਤ੍ਰਿਤ ਗਾਈਡ ਪ੍ਰਦਾਨ ਕਰਦਾ ਹੈ। ਇਸ ਵਿੱਚ ਸਟ੍ਰੀਮਿੰਗ ਲਈ ਪ੍ਰੇਰਣਾ, ਉਪਲਬਧ ਟ੍ਰਾਂਸਪੋਰਟ ਮਕੈਨਿਜ਼ਮ, MCP ਵਿੱਚ ਸਟ੍ਰੀਮਬਲ HTTP ਨੂੰ ਕਿਵੇਂ ਲਾਗੂ ਕਰਨਾ ਹੈ, ਸੁਰੱਖਿਆ ਲਈ ਸਭ ਤੋਂ ਵਧੀਆ ਅਭਿਆਸ, SSE ਤੋਂ ਮਾਈਗ੍ਰੇਸ਼ਨ, ਅਤੇ ਆਪਣੇ ਸਟ੍ਰੀਮਿੰਗ MCP ਐਪਲੀਕੇਸ਼ਨ ਬਣਾਉਣ ਲਈ ਪ੍ਰੈਕਟਿਕਲ ਮਾਰਗਦਰਸ਼ਨ ਸ਼ਾਮਲ ਹੈ।

## ਟ੍ਰਾਂਸਪੋਰਟ ਮਕੈਨਿਜ਼ਮ ਅਤੇ MCP ਵਿੱਚ ਸਟ੍ਰੀਮਿੰਗ

ਇਸ ਭਾਗ ਵਿੱਚ MCP ਵਿੱਚ ਉਪਲਬਧ ਵੱਖ-ਵੱਖ ਟ੍ਰਾਂਸਪੋਰਟ ਮਕੈਨਿਜ਼ਮ ਅਤੇ ਕਲਾਇੰਟ ਅਤੇ ਸਰਵਰ ਦੇ ਵਿਚਕਾਰ ਰੀਅਲ-ਟਾਈਮ ਸੰਚਾਰ ਲਈ ਸਟ੍ਰੀਮਿੰਗ ਸਮਰੱਥਾਵਾਂ ਨੂੰ ਯੋਗ ਕਰਨ ਵਿੱਚ ਉਨ੍ਹਾਂ ਦੀ ਭੂਮਿਕਾ ਦੀ ਪੜਚੋਲ ਕੀਤੀ ਗਈ ਹੈ।

### ਟ੍ਰਾਂਸਪੋਰਟ ਮਕੈਨਿਜ਼ਮ ਕੀ ਹੈ?

ਟ੍ਰਾਂਸਪੋਰਟ ਮਕੈਨਿਜ਼ਮ ਇਹ ਪਰਿਭਾਸ਼ਿਤ ਕਰਦਾ ਹੈ ਕਿ ਕਲਾਇੰਟ ਅਤੇ ਸਰਵਰ ਦੇ ਵਿਚਕਾਰ ਡਾਟਾ ਕਿਵੇਂ ਅਦਲਾ-ਬਦਲੀ ਹੁੰਦੀ ਹੈ। MCP ਵੱਖ-ਵੱਖ ਵਾਤਾਵਰਣਾਂ ਅਤੇ ਲੋੜਾਂ ਨੂੰ ਪੂਰਾ ਕਰਨ ਲਈ ਕਈ ਟ੍ਰਾਂਸਪੋਰਟ ਪ੍ਰਕਾਰਾਂ ਦਾ ਸਮਰਥਨ ਕਰਦਾ ਹੈ:

- **stdio**: ਸਟੈਂਡਰਡ ਇਨਪੁਟ/ਆਉਟਪੁਟ, ਸਥਾਨਕ ਅਤੇ CLI-ਅਧਾਰਿਤ ਟੂਲਾਂ ਲਈ ਉਚਿਤ। ਸਧਾਰਣ ਪਰ ਵੈੱਬ ਜਾਂ ਕਲਾਉਡ ਲਈ ਉਚਿਤ ਨਹੀਂ।
- **SSE (ਸਰਵਰ-ਸੈਂਟ ਇਵੈਂਟਸ)**: ਸਰਵਰਾਂ ਨੂੰ HTTP ਰਾਹੀਂ ਕਲਾਇੰਟਸ ਨੂੰ ਰੀਅਲ-ਟਾਈਮ ਅੱਪਡੇਟ ਪੇਸ਼ ਕਰਨ ਦੀ ਆਗਿਆ ਦਿੰਦਾ ਹੈ। ਵੈੱਬ UI ਲਈ ਚੰਗਾ ਹੈ, ਪਰ ਸਕੇਲਬਿਲਟੀ ਅਤੇ ਲਚਕਤਾ ਵਿੱਚ ਸੀਮਤ।
- **ਸਟ੍ਰੀਮਬਲ HTTP**: ਆਧੁਨਿਕ HTTP-ਅਧਾਰਿਤ ਸਟ੍ਰੀਮਿੰਗ ਟ੍ਰਾਂਸਪੋਰਟ, ਨੋਟੀਫਿਕੇਸ਼ਨ ਅਤੇ ਵਧੀਆ ਸਕੇਲਬਿਲਟੀ ਦਾ ਸਮਰਥਨ ਕਰਦਾ ਹੈ। ਜ਼ਿਆਦਾਤਰ ਪ੍ਰੋਡਕਸ਼ਨ ਅਤੇ ਕਲਾਉਡ ਸਥਿਤੀਆਂ ਲਈ ਸਿਫਾਰਸ਼ ਕੀਤੀ ਗਈ।

### ਤੁਲਨਾਤਮਕ ਟੇਬਲ

ਹੇਠਾਂ ਦਿੱਤੀ ਟੇਬਲ ਵਿੱਚ ਟ੍ਰਾਂਸਪੋਰਟ ਮਕੈਨਿਜ਼ਮ ਦੇ ਅੰਤਰਾਂ ਨੂੰ ਸਮਝਣ ਲਈ ਇੱਕ ਝਲਕ ਪਾਓ:

| ਟ੍ਰਾਂਸਪੋਰਟ         | ਰੀਅਲ-ਟਾਈਮ ਅੱਪਡੇਟਸ | ਸਟ੍ਰੀਮਿੰਗ | ਸਕੇਲਬਿਲਟੀ | ਵਰਤੋਂ ਦਾ ਕੇਸ            |
|-------------------|------------------|-----------|-------------|-------------------------|
| stdio             | ਨਹੀਂ               | ਨਹੀਂ        | ਘੱਟ         | ਸਥਾਨਕ CLI ਟੂਲ          |
| SSE               | ਹਾਂ              | ਹਾਂ       | ਦਰਮਿਆਨਾ      | ਵੈੱਬ, ਰੀਅਲ-ਟਾਈਮ ਅੱਪਡੇਟ  |
| ਸਟ੍ਰੀਮਬਲ HTTP     | ਹਾਂ              | ਹਾਂ       | ਉੱਚਾ         | ਕਲਾਉਡ, ਮਲਟੀ-ਕਲਾਇੰਟ     |

> **ਸੁਝਾਅ:** ਸਹੀ ਟ੍ਰਾਂਸਪੋਰਟ ਚੁਣਨਾ ਪ੍ਰਦਰਸ਼ਨ, ਸਕੇਲਬਿਲਟੀ, ਅਤੇ ਯੂਜ਼ਰ ਅਨੁਭਵ ਨੂੰ ਪ੍ਰਭਾਵਿਤ ਕਰਦਾ ਹੈ। **ਸਟ੍ਰੀਮਬਲ HTTP** ਆਧੁਨਿਕ, ਸਕੇਲਬਲ ਅਤੇ ਕਲਾਉਡ-ਤਿਆਰ ਐਪਲੀਕੇਸ਼ਨਾਂ ਲਈ ਸਿਫਾਰਸ਼ ਕੀਤੀ ਜਾਂਦੀ ਹੈ।

ਪਿਛਲੇ ਅਧਿਆਇ ਵਿੱਚ ਤੁਹਾਨੂੰ stdio ਅਤੇ SSE ਟ੍ਰਾਂਸਪੋਰਟ ਦਿਖਾਏ ਗਏ ਸਨ ਅਤੇ ਇਸ ਅਧਿਆਇ ਵਿੱਚ ਕਵਰ ਕੀਤੇ ਗਏ ਸਟ੍ਰੀਮਬਲ HTTP ਟ੍ਰਾਂਸਪੋਰਟ ਨੂੰ ਨੋਟ ਕਰੋ।

## ਸਟ੍ਰੀਮਿੰਗ: ਸੰਕਲਪ ਅਤੇ ਪ੍ਰੇਰਣਾ

ਰੀਅਲ-ਟਾਈਮ ਸੰਚਾਰ ਪ੍ਰਣਾਲੀਆਂ ਨੂੰ ਲਾਗੂ ਕਰਨ ਲਈ ਸਟ੍ਰੀਮਿੰਗ ਦੇ ਮੂਲ ਸੰਕਲਪਾਂ ਅਤੇ ਪ੍ਰੇਰਣਾਵਾਂ ਨੂੰ ਸਮਝਣਾ ਜ਼ਰੂਰੀ ਹੈ।

**ਸਟ੍ਰੀਮਿੰਗ** ਨੈੱਟਵਰਕ ਪ੍ਰੋਗਰਾਮਿੰਗ ਵਿੱਚ ਇੱਕ ਤਕਨੀਕ ਹੈ ਜੋ ਡਾਟਾ ਨੂੰ ਛੋਟੇ, ਪ੍ਰਬੰਧਨਯੋਗ ਹਿੱਸਿਆਂ ਜਾਂ ਘਟਨਾਵਾਂ ਦੀ ਲੜੀ ਵਜੋਂ ਭੇਜਣ ਅਤੇ ਪ੍ਰਾਪਤ ਕਰਨ ਦੀ ਆਗਿਆ ਦਿੰਦੀ ਹੈ, ਬਜਾਏ ਇਸਦੇ ਕਿ ਪੂਰਾ ਜਵਾਬ ਤਿਆਰ ਹੋਣ ਦੀ ਉਡੀਕ ਕੀਤੀ ਜਾਵੇ। ਇਹ ਖਾਸ ਤੌਰ 'ਤੇ ਹੇਠਾਂ ਦਿੱਤੇ ਲਈ ਲਾਭਦਾਇਕ ਹੈ:

- ਵੱਡੇ ਫਾਈਲਾਂ ਜਾਂ ਡਾਟਾਸੈਟ।
- ਰੀਅਲ-ਟਾਈਮ ਅੱਪਡੇਟਸ (ਜਿਵੇਂ ਕਿ ਚੈਟ, ਪ੍ਰੋਗਰੈਸ ਬਾਰ)।
- ਲੰਬੇ ਸਮੇਂ ਚੱਲਣ ਵਾਲੀਆਂ ਗਣਨਾਵਾਂ ਜਿੱਥੇ ਤੁਸੀਂ ਯੂਜ਼ਰ ਨੂੰ ਜਾਣਕਾਰੀ ਦੇਣੀ ਚਾਹੁੰਦੇ ਹੋ।

ਇੱਥੇ ਸਟ੍ਰੀਮਿੰਗ ਬਾਰੇ ਕੁਝ ਮੁੱਖ ਗੱਲਾਂ ਹਨ:

- ਡਾਟਾ ਪ੍ਰਗਤੀਸ਼ੀਲ ਤੌਰ 'ਤੇ ਡਿਲੀਵਰ ਕੀਤਾ ਜਾਂਦਾ ਹੈ, ਸਾਰਾ ਇਕੱਠੇ ਨਹੀਂ।
- ਕਲਾਇੰਟ ਡਾਟਾ ਨੂੰ ਉਸ ਸਮੇਂ ਪ੍ਰਕਿਰਿਆ ਕਰ ਸਕਦਾ ਹੈ ਜਦੋਂ ਇਹ ਪਹੁੰਚਦਾ ਹੈ।
- ਧਾਰਿਤ ਲੈਟੈਂਸੀ ਨੂੰ ਘਟਾਉਂਦਾ ਹੈ ਅਤੇ ਯੂਜ਼ਰ ਅਨੁਭਵ ਨੂੰ ਸੁਧਾਰਦਾ ਹੈ।

### ਸਟ੍ਰੀਮਿੰਗ ਕਿਉਂ ਵਰਤੋਂ?

ਸਟ੍ਰੀਮਿੰਗ ਵਰਤਣ ਦੇ ਕਾਰਨ ਹੇਠਾਂ ਦਿੱਤੇ ਹਨ:

- ਯੂਜ਼ਰ ਨੂੰ ਤੁਰੰਤ ਫੀਡਬੈਕ ਮਿਲਦਾ ਹੈ, ਸਿਰਫ ਅੰਤ ਵਿੱਚ ਨਹੀਂ।
- ਰੀਅਲ-ਟਾਈਮ ਐਪਲੀਕੇਸ਼ਨ ਅਤੇ ਪ੍ਰਤੀਕ੍ਰਿਆਸ਼ੀਲ UI ਯੋਗ ਬਣਾਉਂਦਾ ਹੈ।
- ਨੈੱਟਵਰਕ ਅਤੇ ਕੰਪਿਊਟ ਸਰੋਤਾਂ ਦੀ ਵਧੀਆ ਵਰਤੋਂ।

### ਸਧਾਰਣ ਉਦਾਹਰਣ: HTTP ਸਟ੍ਰੀਮਿੰਗ ਸਰਵਰ ਅਤੇ ਕਲਾਇੰਟ

ਇੱਥੇ ਇੱਕ ਸਧਾਰਣ ਉਦਾਹਰਣ ਹੈ ਕਿ ਸਟ੍ਰੀਮਿੰਗ ਨੂੰ ਕਿਵੇਂ ਲਾਗੂ ਕੀਤਾ ਜਾ ਸਕਦਾ ਹੈ:

#### ਪਾਈਥਨ

**ਸਰਵਰ (ਪਾਈਥਨ, FastAPI ਅਤੇ StreamingResponse ਦੀ ਵਰਤੋਂ ਕਰਦੇ ਹੋਏ):**

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

**ਕਲਾਇੰਟ (ਪਾਈਥਨ, requests ਦੀ ਵਰਤੋਂ ਕਰਦੇ ਹੋਏ):**

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

ਇਹ ਉਦਾਹਰਣ ਦਿਖਾਉਂਦਾ ਹੈ ਕਿ ਸਰਵਰ ਕਲਾਇੰਟ ਨੂੰ ਸੁਨੇਹੇ ਦੀ ਲੜੀ ਭੇਜਦਾ ਹੈ ਜਿਵੇਂ ਕਿ ਉਹ ਉਪਲਬਧ ਹੁੰਦੇ ਹਨ, ਸਾਰੇ ਸੁਨੇਹੇ ਤਿਆਰ ਹੋਣ ਦੀ ਉਡੀਕ ਕਰਨ ਦੀ ਬਜਾਏ।

**ਇਹ ਕਿਵੇਂ ਕੰਮ ਕਰਦਾ ਹੈ:**

- ਸਰਵਰ ਹਰ ਸੁਨੇਹਾ ਜਦੋਂ ਤਿਆਰ ਹੁੰਦਾ ਹੈ ਤਦੋਂ ਭੇਜਦਾ ਹੈ।
- ਕਲਾਇੰਟ ਹਰ ਚੰਕ ਨੂੰ ਪ੍ਰਾਪਤ ਕਰਦਾ ਹੈ ਅਤੇ ਪ੍ਰਿੰਟ ਕਰਦਾ ਹੈ ਜਿਵੇਂ ਕਿ ਇਹ ਪਹੁੰਚਦਾ ਹੈ।

**ਲੋੜਾਂ:**

- ਸਰਵਰ ਨੂੰ ਸਟ੍ਰੀਮਿੰਗ ਜਵਾਬ ਦੀ ਵਰਤੋਂ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ (ਜਿਵੇਂ ਕਿ FastAPI ਵਿੱਚ `StreamingResponse`)।
- ਕਲਾਇੰਟ ਨੂੰ ਜਵਾਬ ਨੂੰ ਸਟ੍ਰੀਮ ਵਜੋਂ ਪ੍ਰਕਿਰਿਆ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ (`stream=True` requests ਵਿੱਚ)।
- ਸਮੱਗਰੀ ਦੀ ਕਿਸਮ ਆਮ ਤੌਰ 'ਤੇ `text/event-stream` ਜਾਂ `application/octet-stream` ਹੁੰਦੀ ਹੈ।

#### ਜਾਵਾ

**ਸਰਵਰ (ਜਾਵਾ, Spring Boot ਅਤੇ Server-Sent Events ਦੀ ਵਰਤੋਂ ਕਰਦੇ ਹੋਏ):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**ਕਲਾਇੰਟ (ਜਾਵਾ, Spring WebFlux WebClient ਦੀ ਵਰਤੋਂ ਕਰਦੇ ਹੋਏ):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**ਜਾਵਾ ਲਾਗੂ ਕਰਨ ਦੇ ਨੋਟਸ:**

- Spring Boot ਦੇ ਰਿਐਕਟਿਵ ਸਟੈਕ ਨਾਲ `Flux` ਲਈ ਸਟ੍ਰੀਮਿੰਗ ਦੀ ਵਰਤੋਂ ਕਰਦਾ ਹੈ।
- `ServerSentEvent` ਘਟਨਾ ਦੇ ਪ੍ਰਕਾਰਾਂ ਨਾਲ ਸਟ੍ਰਕਚਰਡ ਸਟ੍ਰੀਮਿੰਗ ਪ੍ਰਦਾਨ ਕਰਦਾ ਹੈ।
- `bodyToFlux()` ਨਾਲ `WebClient` ਰਿਐਕਟਿਵ ਸਟ੍ਰੀਮਿੰਗ ਖਪਤ ਯੋਗ ਬਣਾਉਂਦਾ ਹੈ।
- `delayElements()` ਘਟਨਾਵਾਂ ਦੇ ਵਿਚਕਾਰ ਪ੍ਰਕਿਰਿਆ ਸਮੇਂ ਦਾ ਅਨੁਕਰਣ ਕਰਦਾ ਹੈ।
- ਘਟਨਾਵਾਂ ਵਿੱਚ ਬਿਹਤਰ ਕਲਾਇੰਟ ਸੰਭਾਲ ਲਈ ਪ੍ਰਕਾਰ (`info`, `result`) ਹੋ ਸਕਦੇ ਹਨ।

### ਤੁਲਨਾ: ਕਲਾਸਿਕ ਸਟ੍ਰੀਮਿੰਗ ਵਿਰੁੱਧ MCP ਸਟ੍ਰੀਮਿੰਗ

ਕਲਾਸਿਕ ਢੰਗ ਨਾਲ ਸਟ੍ਰੀਮਿੰਗ ਕੰਮ ਕਰਦੀ ਹੈ ਅਤੇ MCP ਵਿੱਚ ਇਸ ਦੇ ਕੰਮ ਕਰਨ ਦੇ ਢੰਗ ਵਿੱਚ ਅੰਤਰ ਹੇਠਾਂ ਦਿੱਤੇ ਗਏ ਹਨ:

| ਵਿਸ਼ੇਸ਼ਤਾ                | ਕਲਾਸਿਕ HTTP ਸਟ੍ਰੀਮਿੰਗ         | MCP ਸਟ੍ਰੀਮਿੰਗ (ਨੋਟੀਫਿਕੇਸ਼ਨ)      |
|------------------------|-------------------------------|-------------------------------------|
| ਮੁੱਖ ਜਵਾਬ          | ਚੰਕਡ                        | ਸਿੰਗਲ, ਅੰਤ ਵਿੱਚ                      |
| ਪ੍ਰਗਤੀ ਅੱਪਡੇਟਸ       | ਡਾਟਾ ਚੰਕ ਵਜੋਂ ਭੇਜੇ ਜਾਂਦੇ ਹਨ           | ਨੋਟੀਫਿਕੇਸ਼ਨ ਵਜੋਂ ਭੇਜੇ ਜਾਂਦੇ ਹਨ               |
| ਕਲਾਇੰਟ ਦੀਆਂ ਲੋੜਾਂ    | ਸਟ੍ਰੀਮ ਪ੍ਰਕਿਰਿਆ ਕਰਨੀ ਪਵੇਗੀ           | ਸੁਨੇਹਾ ਸੰਭਾਲਕ ਲਾਗੂ ਕਰਨਾ ਪਵੇਗਾ            |
| ਵਰਤੋਂ ਦਾ ਕੇਸ               | ਵੱਡੀਆਂ ਫਾਈਲਾਂ, AI ਟੋਕਨ ਸਟ੍ਰੀਮ | ਪ੍ਰਗਤੀ, ਲਾਗ, ਰੀਅਲ-ਟਾਈਮ ਫੀਡਬੈਕ  |

### ਮੁੱਖ ਅੰਤਰ

ਇਸ ਤੋਂ ਇਲਾਵਾ, ਕੁਝ ਮੁੱਖ ਅੰਤਰ ਹਨ:

- **ਸੰਚਾਰ ਪੈਟਰਨ:**
  - ਕਲਾਸਿਕ HTTP ਸਟ੍ਰੀਮਿੰਗ: ਡਾਟਾ ਨੂੰ ਚੰਕਡ ਟ੍ਰਾਂਸਫਰ ਐਨਕੋਡਿੰਗ ਨਾਲ ਭੇਜਦਾ ਹੈ।
  - MCP ਸਟ੍ਰੀਮਿੰਗ: JSON-RPC ਪ੍ਰੋਟੋਕੋਲ ਨਾਲ ਸਟ੍ਰਕਚਰਡ ਨੋਟੀਫਿਕੇਸ਼ਨ ਸਿਸਟਮ ਦੀ ਵਰਤੋਂ ਕਰਦਾ ਹੈ।

- **ਸੁਨੇਹਾ ਫਾਰਮੈਟ:**
  - ਕਲਾਸਿਕ HTTP: ਨਿਊਲਾਈਨ ਨਾਲ ਸਧਾਰਣ ਟੈਕਸਟ ਚੰਕ।
  - MCP: ਮੈਟਾਡੇਟਾ ਨਾਲ ਸਟ੍ਰਕਚਰਡ LoggingMessageNotification ਆਬਜੈਕਟ।

- **ਕਲਾਇੰਟ ਲਾਗੂ ਕਰਨਾ:**
  - ਕਲਾਸਿਕ HTTP: ਸਧਾਰਣ ਕਲਾਇੰਟ ਜੋ ਸਟ੍ਰੀਮਿੰਗ ਜਵਾਬ ਪ੍ਰਕਿਰਿਆ ਕਰਦਾ ਹੈ।
  - MCP: ਵੱਖ-ਵੱਖ ਪ੍ਰਕਾਰ ਦੇ ਸੁਨੇਹਿਆਂ ਨੂੰ ਪ੍ਰਕਿਰਿਆ ਕਰਨ ਲਈ ਸੁਨੇਹਾ ਸੰਭਾਲਕ ਵਾਲਾ ਜਟਿਲ ਕਲਾਇੰਟ।

- **ਪ੍ਰਗਤੀ ਅੱਪਡੇਟਸ:**
  - ਕਲਾਸਿਕ HTTP: ਪ੍ਰਗਤੀ ਮੁੱਖ ਜਵਾਬ ਸਟ੍ਰੀਮ ਦਾ ਹਿੱਸਾ ਹੈ।
  - MCP: ਪ੍ਰਗਤੀ ਵੱਖਰੇ ਨੋਟੀਫਿਕੇਸ਼ਨ ਸੁਨੇਹਿਆਂ ਰਾਹੀਂ ਭੇਜੀ ਜਾਂਦੀ ਹੈ ਜਦੋਂ ਕਿ ਮੁੱਖ ਜਵਾਬ ਅੰਤ ਵਿੱਚ ਆਉਂਦਾ ਹੈ।

### ਸਿਫਾਰਸ਼ਾਂ

ਕਲਾਸਿਕ ਸਟ੍ਰੀਮਿੰਗ (ਜਿਵੇਂ `/stream` ਐਂਡਪੌਇੰਟ) ਨੂੰ ਲਾਗੂ ਕਰਨ ਅਤੇ MCP ਰਾਹੀਂ ਸਟ੍ਰੀਮਿੰਗ ਚੁਣਨ ਦੇ ਵਿਚਕਾਰ ਚੋਣ ਕਰਨ ਲਈ ਕੁਝ ਸਿਫਾਰਸ਼ਾਂ ਹਨ:

- **ਸਧਾਰਣ ਸਟ੍ਰੀਮਿੰਗ ਦੀਆਂ ਲੋੜਾਂ ਲਈ:** ਕਲਾਸਿਕ HTTP ਸਟ੍ਰੀਮਿੰਗ ਲਾਗੂ ਕਰਨ ਲਈ ਸਧਾਰਣ ਹੈ ਅਤੇ ਬੁਨਿਆਦੀ ਸਟ੍ਰੀਮਿੰਗ ਦੀਆਂ ਲੋੜਾਂ ਲਈ ਕਾਫ਼ੀ ਹੈ।

- **ਜਟਿਲ, ਇੰਟਰਐਕਟਿਵ ਐਪਲੀਕੇਸ਼ਨਾਂ ਲਈ:** MCP ਸਟ੍ਰੀਮਿੰਗ ਇੱਕ ਵਧੇਰੇ ਸਟ੍ਰਕਚਰਡ ਪਹੁੰਚ ਪ੍ਰਦਾਨ ਕਰਦੀ ਹੈ ਜਿਸ ਵਿੱਚ ਵਧੇਰੇ ਮੈਟਾਡੇਟਾ ਅਤੇ ਨੋਟੀਫਿਕੇਸ਼ਨ ਅਤੇ ਅੰਤਿਮ ਨਤੀਜਿਆਂ ਦੇ ਵਿਚਕਾਰ ਵੱਖਰਾ ਹੁੰਦਾ ਹੈ।

- **AI ਐਪਲੀਕੇਸ਼ਨਾਂ ਲਈ:** ਲੰਬੇ ਸਮੇਂ ਚੱਲਣ ਵਾਲੇ AI ਕੰਮਾਂ ਲਈ MCP ਦਾ ਨੋਟੀਫਿਕੇਸ਼ਨ ਸਿਸਟਮ ਖਾਸ ਤੌਰ 'ਤੇ ਲਾਭਦਾਇਕ ਹੈ ਜਿੱਥੇ ਤੁਸੀਂ ਯੂਜ਼ਰ ਨੂੰ ਪ੍ਰਗਤੀ ਬਾਰੇ ਜਾਣਕਾਰੀ ਦੇਣੀ ਚਾਹੁੰਦੇ ਹੋ।
SSE ਤੋਂ Streamable HTTP ਵਿੱਚ ਅੱਪਗ੍ਰੇਡ ਕਰਨ ਦੇ ਦੋ ਮੁੱਖ ਕਾਰਨ ਹਨ:

- Streamable HTTP, SSE ਨਾਲੋਂ ਵਧੀਆ ਸਕੇਲਬਿਲਟੀ, ਅਨੁਕੂਲਤਾ ਅਤੇ ਵਧੀਆ ਨੋਟੀਫਿਕੇਸ਼ਨ ਸਹਾਇਤਾ ਪ੍ਰਦਾਨ ਕਰਦਾ ਹੈ।
- ਇਹ ਨਵੀਆਂ MCP ਐਪਲੀਕੇਸ਼ਨਾਂ ਲਈ ਸਿਫਾਰਸ਼ੀ ਟ੍ਰਾਂਸਪੋਰਟ ਹੈ।

### ਮਾਈਗ੍ਰੇਸ਼ਨ ਦੇ ਕਦਮ

ਇਹ ਹੈ ਕਿ ਤੁਸੀਂ ਆਪਣੀਆਂ MCP ਐਪਲੀਕੇਸ਼ਨਾਂ ਵਿੱਚ SSE ਤੋਂ Streamable HTTP ਵਿੱਚ ਕਿਵੇਂ ਮਾਈਗ੍ਰੇਟ ਕਰ ਸਕਦੇ ਹੋ:

- **ਸਰਵਰ ਕੋਡ ਅੱਪਡੇਟ ਕਰੋ** ਤਾਂ ਜੋ `mcp.run()` ਵਿੱਚ `transport="streamable-http"` ਵਰਤਿਆ ਜਾਵੇ।
- **ਕਲਾਇੰਟ ਕੋਡ ਅੱਪਡੇਟ ਕਰੋ** ਤਾਂ ਜੋ SSE ਕਲਾਇੰਟ ਦੀ ਥਾਂ `streamablehttp_client` ਵਰਤਿਆ ਜਾਵੇ।
- **ਕਲਾਇੰਟ ਵਿੱਚ ਇੱਕ ਸੁਨੇਹਾ ਹੈਂਡਲਰ ਲਾਗੂ ਕਰੋ** ਜੋ ਨੋਟੀਫਿਕੇਸ਼ਨ ਪ੍ਰਕਿਰਿਆ ਕਰੇ।
- **ਮੌਜੂਦਾ ਟੂਲਜ਼ ਅਤੇ ਵਰਕਫਲੋਜ਼ ਨਾਲ ਅਨੁਕੂਲਤਾ ਦੀ ਜਾਂਚ ਕਰੋ।**

### ਅਨੁਕੂਲਤਾ ਕਾਇਮ ਰੱਖਣਾ

ਮਾਈਗ੍ਰੇਸ਼ਨ ਪ੍ਰਕਿਰਿਆ ਦੌਰਾਨ ਮੌਜੂਦਾ SSE ਕਲਾਇੰਟਸ ਨਾਲ ਅਨੁਕੂਲਤਾ ਕਾਇਮ ਰੱਖਣ ਦੀ ਸਿਫਾਰਸ਼ ਕੀਤੀ ਜਾਂਦੀ ਹੈ। ਇੱਥੇ ਕੁਝ ਰਣਨੀਤੀਆਂ ਹਨ:

- ਤੁਸੀਂ ਵੱਖ-ਵੱਖ ਐਂਡਪੌਇੰਟਸ 'ਤੇ ਦੋਨੋ ਟ੍ਰਾਂਸਪੋਰਟ (SSE ਅਤੇ Streamable HTTP) ਚਲਾ ਕੇ ਦੋਨੋ ਦਾ ਸਮਰਥਨ ਕਰ ਸਕਦੇ ਹੋ।
- ਕਲਾਇੰਟਸ ਨੂੰ ਨਵੇਂ ਟ੍ਰਾਂਸਪੋਰਟ 'ਤੇ ਹੌਲੀ-ਹੌਲੀ ਮਾਈਗ੍ਰੇਟ ਕਰੋ।

### ਚੁਣੌਤੀਆਂ

ਮਾਈਗ੍ਰੇਸ਼ਨ ਦੌਰਾਨ ਹੇਠਾਂ ਦਿੱਤੀਆਂ ਚੁਣੌਤੀਆਂ ਦਾ ਧਿਆਨ ਰੱਖੋ:

- ਯਕੀਨੀ ਬਣਾਓ ਕਿ ਸਾਰੇ ਕਲਾਇੰਟਸ ਅੱਪਡੇਟ ਕੀਤੇ ਗਏ ਹਨ।
- ਨੋਟੀਫਿਕੇਸ਼ਨ ਡਿਲਿਵਰੀ ਵਿੱਚ ਅੰਤਰਾਂ ਨੂੰ ਸੰਭਾਲਣਾ।

## ਸੁਰੱਖਿਆ ਦੇ ਵਿਚਾਰ

ਜਦੋਂ HTTP-ਅਧਾਰਿਤ ਟ੍ਰਾਂਸਪੋਰਟ ਜਿਵੇਂ ਕਿ Streamable HTTP ਨੂੰ MCP ਵਿੱਚ ਲਾਗੂ ਕੀਤਾ ਜਾਂਦਾ ਹੈ, ਤਾਂ ਸੁਰੱਖਿਆ ਸਭ ਤੋਂ ਵੱਡੀ ਤਰਜੀਹ ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ।

HTTP-ਅਧਾਰਿਤ ਟ੍ਰਾਂਸਪੋਰਟ ਨਾਲ MCP ਸਰਵਰ ਲਾਗੂ ਕਰਦੇ ਸਮੇਂ, ਸੁਰੱਖਿਆ ਇੱਕ ਮਹੱਤਵਪੂਰਨ ਚਿੰਤਾ ਹੈ ਜੋ ਕਈ ਹਮਲੇ ਦੇ ਰਸਤੇ ਅਤੇ ਸੁਰੱਖਿਆ ਮਕੈਨਿਜ਼ਮਾਂ ਲਈ ਧਿਆਨ ਦੀ ਲੋੜ ਹੈ।

### ਓਵਰਵਿਊ

ਜਦੋਂ HTTP ਰਾਹੀਂ MCP ਸਰਵਰਜ਼ ਨੂੰ ਐਕਸਪੋਜ਼ ਕੀਤਾ ਜਾਂਦਾ ਹੈ, ਤਾਂ ਸੁਰੱਖਿਆ ਮਹੱਤਵਪੂਰਨ ਹੁੰਦੀ ਹੈ। Streamable HTTP ਨਵੇਂ ਹਮਲੇ ਦੇ ਰਸਤੇ ਪੈਦਾ ਕਰਦਾ ਹੈ ਅਤੇ ਧਿਆਨਪੂਰਵਕ ਸੰਰਚਨਾ ਦੀ ਲੋੜ ਹੁੰਦੀ ਹੈ।

ਇੱਥੇ ਕੁਝ ਮੁੱਖ ਸੁਰੱਖਿਆ ਦੇ ਵਿਚਾਰ ਹਨ:

- **Origin ਹੈਡਰ ਵੈਲੀਡੇਸ਼ਨ**: DNS ਰੀਬਾਈਡਿੰਗ ਹਮਲਿਆਂ ਤੋਂ ਬਚਣ ਲਈ ਹਮੇਸ਼ਾ `Origin` ਹੈਡਰ ਦੀ ਜਾਂਚ ਕਰੋ।
- **ਲੋਕਲਹੋਸਟ ਬਾਈਂਡਿੰਗ**: ਸਥਾਨਕ ਵਿਕਾਸ ਲਈ, ਸਰਵਰਜ਼ ਨੂੰ `localhost` ਨਾਲ ਬਾਈਂਡ ਕਰੋ ਤਾਂ ਜੋ ਉਹ ਜਨਤਕ ਇੰਟਰਨੈਟ 'ਤੇ ਐਕਸਪੋਜ਼ ਨਾ ਹੋਣ।
- **ਪ੍ਰਮਾਣਿਕਤਾ**: ਉਤਪਾਦਨ ਡਿਪਲੌਇਮੈਂਟ ਲਈ ਪ੍ਰਮਾਣਿਕਤਾ (ਜਿਵੇਂ API ਕੁੰਜੀਆਂ, OAuth) ਲਾਗੂ ਕਰੋ।
- **CORS**: ਪਹੁੰਚ ਨੂੰ ਸੀਮਿਤ ਕਰਨ ਲਈ Cross-Origin Resource Sharing (CORS) ਨੀਤੀਆਂ ਨੂੰ ਸੰਰਚਿਤ ਕਰੋ।
- **HTTPS**: ਉਤਪਾਦਨ ਵਿੱਚ ਟ੍ਰੈਫਿਕ ਨੂੰ ਇੰਕ੍ਰਿਪਟ ਕਰਨ ਲਈ HTTPS ਵਰਤੋ।

### ਬਿਹਤਰ ਅਭਿਆਸ

ਇਸ ਤੋਂ ਇਲਾਵਾ, ਜਦੋਂ ਆਪਣੇ MCP ਸਟ੍ਰੀਮਿੰਗ ਸਰਵਰ ਵਿੱਚ ਸੁਰੱਖਿਆ ਲਾਗੂ ਕਰਦੇ ਹੋ, ਤਾਂ ਹੇਠਾਂ ਦਿੱਤੇ ਬਿਹਤਰ ਅਭਿਆਸਾਂ ਦੀ ਪਾਲਣਾ ਕਰੋ:

- ਆਉਣ ਵਾਲੇ ਬੇਨਤੀ ਨੂੰ ਬਿਨਾਂ ਵੈਲੀਡੇਸ਼ਨ ਦੇ ਕਦੇ ਵੀ ਭਰੋਸਾ ਨਾ ਕਰੋ।
- ਸਾਰੀ ਪਹੁੰਚ ਅਤੇ ਗਲਤੀਆਂ ਨੂੰ ਲੌਗ ਅਤੇ ਮਾਨੀਟਰ ਕਰੋ।
- ਸੁਰੱਖਿਆ ਦੀਆਂ ਕਮਜ਼ੋਰੀਆਂ ਨੂੰ ਪੈਚ ਕਰਨ ਲਈ ਨਿਰੰਤਰ ਡਿਪੈਂਡੇੰਸੀਜ਼ ਨੂੰ ਅੱਪਡੇਟ ਕਰੋ।

### ਚੁਣੌਤੀਆਂ

MCP ਸਟ੍ਰੀਮਿੰਗ ਸਰਵਰਜ਼ ਵਿੱਚ ਸੁਰੱਖਿਆ ਲਾਗੂ ਕਰਦੇ ਸਮੇਂ ਤੁਸੀਂ ਕੁਝ ਚੁਣੌਤੀਆਂ ਦਾ ਸਾਹਮਣਾ ਕਰੋਗੇ:

- ਵਿਕਾਸ ਦੀ ਸਹੂਲਤ ਨਾਲ ਸੁਰੱਖਿਆ ਦਾ ਸੰਤੁਲਨ ਬਣਾਉਣਾ।
- ਵੱਖ-ਵੱਖ ਕਲਾਇੰਟ ਵਾਤਾਵਰਣਾਂ ਨਾਲ ਅਨੁਕੂਲਤਾ ਯਕੀਨੀ ਬਣਾਉਣਾ।

### ਅਸਾਈਨਮੈਂਟ: ਆਪਣੀ ਸਟ੍ਰੀਮਿੰਗ MCP ਐਪ ਬਣਾਓ

**ਸਥਿਤੀ:**
ਇੱਕ MCP ਸਰਵਰ ਅਤੇ ਕਲਾਇੰਟ ਬਣਾਓ ਜਿੱਥੇ ਸਰਵਰ ਆਈਟਮਾਂ ਦੀ ਸੂਚੀ (ਜਿਵੇਂ ਫਾਈਲਾਂ ਜਾਂ ਦਸਤਾਵੇਜ਼) ਪ੍ਰਕਿਰਿਆ ਕਰਦਾ ਹੈ ਅਤੇ ਪ੍ਰਤੀਕ ਆਈਟਮ ਪ੍ਰਕਿਰਿਆ ਕੀਤੇ ਜਾਣ 'ਤੇ ਨੋਟੀਫਿਕੇਸ਼ਨ ਭੇਜਦਾ ਹੈ। ਕਲਾਇੰਟ ਨੂੰ ਹਰ ਨੋਟੀਫਿਕੇਸ਼ਨ ਨੂੰ ਰੀਅਲ ਟਾਈਮ ਵਿੱਚ ਦਿਖਾਉਣਾ ਚਾਹੀਦਾ ਹੈ।

**ਕਦਮ:**

1. ਇੱਕ ਸਰਵਰ ਟੂਲ ਲਾਗੂ ਕਰੋ ਜੋ ਸੂਚੀ ਨੂੰ ਪ੍ਰਕਿਰਿਆ ਕਰਦਾ ਹੈ ਅਤੇ ਹਰ ਆਈਟਮ ਲਈ ਨੋਟੀਫਿਕੇਸ਼ਨ ਭੇਜਦਾ ਹੈ।
2. ਇੱਕ ਕਲਾਇੰਟ ਲਾਗੂ ਕਰੋ ਜਿਸ ਵਿੱਚ ਨੋਟੀਫਿਕੇਸ਼ਨ ਨੂੰ ਰੀਅਲ ਟਾਈਮ ਵਿੱਚ ਦਿਖਾਉਣ ਲਈ ਸੁਨੇਹਾ ਹੈਂਡਲਰ ਹੋਵੇ।
3. ਆਪਣੀ ਲਾਗੂ ਕੀਤੀ ਗਈ ਸਰਵਰ ਅਤੇ ਕਲਾਇੰਟ ਨੂੰ ਚਲਾ ਕੇ ਜਾਂਚ ਕਰੋ ਅਤੇ ਨੋਟੀਫਿਕੇਸ਼ਨ ਨੂੰ ਦੇਖੋ।

[Solution](./solution/README.md)

## ਹੋਰ ਪੜ੍ਹਾਈ ਅਤੇ ਅਗਲੇ ਕਦਮ

MCP ਸਟ੍ਰੀਮਿੰਗ ਨਾਲ ਆਪਣੀ ਯਾਤਰਾ ਜਾਰੀ ਰੱਖਣ ਅਤੇ ਆਪਣਾ ਗਿਆਨ ਵਧਾਉਣ ਲਈ, ਇਹ ਭਾਗ ਵਾਧੂ ਸਰੋਤ ਅਤੇ ਸੁਝਾਏ ਗਏ ਅਗਲੇ ਕਦਮ ਪ੍ਰਦਾਨ ਕਰਦਾ ਹੈ ਜੋ ਵਧੇਰੇ ਉੱਨਤ ਐਪਲੀਕੇਸ਼ਨ ਬਣਾਉਣ ਲਈ ਹਨ।

### ਹੋਰ ਪੜ੍ਹਾਈ

- [Microsoft: HTTP ਸਟ੍ਰੀਮਿੰਗ ਦਾ ਪਰਿਚਯ](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: ਸਰਵਰ-ਸੈਂਟ ਇਵੈਂਟਸ (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: ASP.NET Core ਵਿੱਚ CORS](https://learn.microsoft.com/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: ਸਟ੍ਰੀਮਿੰਗ ਬੇਨਤੀਆਂ](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### ਅਗਲਾ ਕੀ?

- ਵਧੇਰੇ ਉੱਨਤ MCP ਟੂਲ ਬਣਾਉਣ ਦੀ ਕੋਸ਼ਿਸ਼ ਕਰੋ ਜੋ ਰੀਅਲ-ਟਾਈਮ ਵਿਸ਼ਲੇਸ਼ਣ, ਚੈਟ ਜਾਂ ਸਹਿਯੋਗੀ ਸੰਪਾਦਨ ਲਈ ਸਟ੍ਰੀਮਿੰਗ ਵਰਤਦੇ ਹਨ।
- ਲਾਈਵ UI ਅੱਪਡੇਟ ਲਈ MCP ਸਟ੍ਰੀਮਿੰਗ ਨੂੰ ਫਰੰਟਐਂਡ ਫਰੇਮਵਰਕਸ (React, Vue, ਆਦਿ) ਨਾਲ ਜੋੜਨ ਦੀ ਪੜਚੋਲ ਕਰੋ।
- ਅਗਲਾ: [VSCode ਲਈ AI ਟੂਲਕਿਟ ਦੀ ਵਰਤੋਂ](../07-aitk/README.md)

**ਅਸਵੀਕਾਰਨਾ**:  
ਇਹ ਦਸਤਾਵੇਜ਼ AI ਅਨੁਵਾਦ ਸੇਵਾ [Co-op Translator](https://github.com/Azure/co-op-translator) ਦੀ ਵਰਤੋਂ ਕਰਕੇ ਅਨੁਵਾਦ ਕੀਤਾ ਗਿਆ ਹੈ। ਜਦੋਂ ਕਿ ਅਸੀਂ ਸਹੀ ਹੋਣ ਦੀ ਕੋਸ਼ਿਸ਼ ਕਰਦੇ ਹਾਂ, ਕਿਰਪਾ ਕਰਕੇ ਧਿਆਨ ਦਿਓ ਕਿ ਸਵੈਚਾਲਿਤ ਅਨੁਵਾਦਾਂ ਵਿੱਚ ਗਲਤੀਆਂ ਜਾਂ ਅਸੁਚਤਤਾਵਾਂ ਹੋ ਸਕਦੀਆਂ ਹਨ। ਮੂਲ ਦਸਤਾਵੇਜ਼ ਨੂੰ ਇਸਦੀ ਮੂਲ ਭਾਸ਼ਾ ਵਿੱਚ ਅਧਿਕਾਰਤ ਸਰੋਤ ਮੰਨਿਆ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ। ਮਹੱਤਵਪੂਰਨ ਜਾਣਕਾਰੀ ਲਈ, ਪੇਸ਼ੇਵਰ ਮਨੁੱਖੀ ਅਨੁਵਾਦ ਦੀ ਸਿਫਾਰਸ਼ ਕੀਤੀ ਜਾਂਦੀ ਹੈ। ਇਸ ਅਨੁਵਾਦ ਦੀ ਵਰਤੋਂ ਤੋਂ ਪੈਦਾ ਹੋਣ ਵਾਲੇ ਕਿਸੇ ਵੀ ਗਲਤਫਹਿਮੀ ਜਾਂ ਗਲਤ ਵਿਆਖਿਆ ਲਈ ਅਸੀਂ ਜ਼ਿੰਮੇਵਾਰ ਨਹੀਂ ਹਾਂ।