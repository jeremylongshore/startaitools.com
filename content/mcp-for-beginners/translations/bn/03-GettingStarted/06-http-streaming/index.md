<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "5f1383103523fa822e1fec7ef81904d5",
  "translation_date": "2025-08-18T15:14:27+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "bn"
}
-->
# HTTPS স্ট্রিমিং এবং মডেল কনটেক্সট প্রোটোকল (MCP)

এই অধ্যায়টি HTTPS ব্যবহার করে মডেল কনটেক্সট প্রোটোকল (MCP)-এর মাধ্যমে নিরাপদ, স্কেলযোগ্য এবং রিয়েল-টাইম স্ট্রিমিং বাস্তবায়নের একটি বিস্তৃত গাইড প্রদান করে। এটি স্ট্রিমিংয়ের প্রয়োজনীয়তা, উপলব্ধ ট্রান্সপোর্ট মেকানিজম, MCP-তে স্ট্রিমেবল HTTP বাস্তবায়ন, নিরাপত্তা সেরা অনুশীলন, SSE থেকে মাইগ্রেশন এবং আপনার নিজস্ব MCP স্ট্রিমিং অ্যাপ্লিকেশন তৈরির জন্য ব্যবহারিক নির্দেশিকা কভার করে।

## MCP-তে ট্রান্সপোর্ট মেকানিজম এবং স্ট্রিমিং

এই অংশটি MCP-তে উপলব্ধ বিভিন্ন ট্রান্সপোর্ট মেকানিজম এবং ক্লায়েন্ট ও সার্ভারের মধ্যে রিয়েল-টাইম যোগাযোগ সক্ষম করার ক্ষেত্রে তাদের ভূমিকা বিশ্লেষণ করে।

### ট্রান্সপোর্ট মেকানিজম কী?

একটি ট্রান্সপোর্ট মেকানিজম নির্ধারণ করে কীভাবে ক্লায়েন্ট এবং সার্ভারের মধ্যে ডেটা আদান-প্রদান হয়। MCP বিভিন্ন পরিবেশ এবং প্রয়োজনীয়তার জন্য একাধিক ট্রান্সপোর্ট টাইপ সমর্থন করে:

- **stdio**: স্ট্যান্ডার্ড ইনপুট/আউটপুট, যা স্থানীয় এবং CLI-ভিত্তিক টুলের জন্য উপযুক্ত। সহজ কিন্তু ওয়েব বা ক্লাউডের জন্য উপযুক্ত নয়।
- **SSE (Server-Sent Events)**: সার্ভারকে HTTP-এর মাধ্যমে ক্লায়েন্টে রিয়েল-টাইম আপডেট পুশ করার অনুমতি দেয়। ওয়েব UI-এর জন্য ভালো, তবে স্কেলেবিলিটি এবং নমনীয়তায় সীমিত।
- **Streamable HTTP**: আধুনিক HTTP-ভিত্তিক স্ট্রিমিং ট্রান্সপোর্ট, যা নোটিফিকেশন এবং উন্নত স্কেলেবিলিটি সমর্থন করে। বেশিরভাগ প্রোডাকশন এবং ক্লাউড পরিস্থিতির জন্য সুপারিশকৃত।

### তুলনামূলক টেবিল

নিচের তুলনামূলক টেবিলটি এই ট্রান্সপোর্ট মেকানিজমগুলির মধ্যে পার্থক্য বোঝার জন্য দেখুন:

| ট্রান্সপোর্ট        | রিয়েল-টাইম আপডেট | স্ট্রিমিং | স্কেলেবিলিটি | ব্যবহারের ক্ষেত্র         |
|---------------------|------------------|-----------|-------------|---------------------------|
| stdio              | না               | না        | কম          | স্থানীয় CLI টুল          |
| SSE                | হ্যাঁ             | হ্যাঁ      | মাঝারি      | ওয়েব, রিয়েল-টাইম আপডেট |
| Streamable HTTP    | হ্যাঁ             | হ্যাঁ      | উচ্চ         | ক্লাউড, মাল্টি-ক্লায়েন্ট |

> **টিপ:** সঠিক ট্রান্সপোর্ট নির্বাচন পারফরম্যান্স, স্কেলেবিলিটি এবং ব্যবহারকারীর অভিজ্ঞতাকে প্রভাবিত করে। **Streamable HTTP** আধুনিক, স্কেলযোগ্য এবং ক্লাউড-রেডি অ্যাপ্লিকেশনের জন্য সুপারিশকৃত।

পূর্ববর্তী অধ্যায়গুলিতে stdio এবং SSE ট্রান্সপোর্ট নিয়ে আলোচনা করা হয়েছে, এবং এই অধ্যায়ে Streamable HTTP ট্রান্সপোর্ট কভার করা হয়েছে।

## স্ট্রিমিং: ধারণা এবং প্রয়োজনীয়তা

স্ট্রিমিংয়ের মৌলিক ধারণা এবং প্রয়োজনীয়তা বোঝা কার্যকর রিয়েল-টাইম যোগাযোগ ব্যবস্থা বাস্তবায়নের জন্য অপরিহার্য।

**স্ট্রিমিং** হল নেটওয়ার্ক প্রোগ্রামিংয়ের একটি কৌশল, যা সম্পূর্ণ রেসপন্স প্রস্তুত হওয়ার জন্য অপেক্ষা না করে ডেটা ছোট ছোট অংশে বা ইভেন্টের ক্রমে পাঠানো এবং গ্রহণ করার অনুমতি দেয়। এটি বিশেষভাবে কার্যকর:

- বড় ফাইল বা ডেটাসেটের জন্য।
- রিয়েল-টাইম আপডেটের জন্য (যেমন চ্যাট, প্রগ্রেস বার)।
- দীর্ঘমেয়াদী কম্পিউটেশনের জন্য যেখানে ব্যবহারকারীকে অবহিত রাখা প্রয়োজন।

উচ্চ-স্তরে স্ট্রিমিং সম্পর্কে যা জানা দরকার:

- ডেটা ধাপে ধাপে সরবরাহ করা হয়, একবারে সব নয়।
- ক্লায়েন্ট ডেটা আসার সাথে সাথে প্রক্রিয়া করতে পারে।
- উপলব্ধি করা লেটেন্সি হ্রাস করে এবং ব্যবহারকারীর অভিজ্ঞতা উন্নত করে।

### কেন স্ট্রিমিং ব্যবহার করবেন?

স্ট্রিমিং ব্যবহারের কারণগুলো নিম্নরূপ:

- ব্যবহারকারীরা তাৎক্ষণিক প্রতিক্রিয়া পান, কেবল শেষেই নয়।
- রিয়েল-টাইম অ্যাপ্লিকেশন এবং প্রতিক্রিয়াশীল UI সক্ষম করে।
- নেটওয়ার্ক এবং কম্পিউট রিসোর্সের আরও কার্যকর ব্যবহার।

### সহজ উদাহরণ: HTTP স্ট্রিমিং সার্ভার এবং ক্লায়েন্ট

স্ট্রিমিং কীভাবে বাস্তবায়ন করা যায় তার একটি সহজ উদাহরণ এখানে দেওয়া হল:

#### পাইথন

**সার্ভার (পাইথন, FastAPI এবং StreamingResponse ব্যবহার করে):**

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

**ক্লায়েন্ট (পাইথন, requests ব্যবহার করে):**

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

এই উদাহরণটি দেখায় কীভাবে একটি সার্ভার ক্লায়েন্টে বার্তা পাঠায় যখনই বার্তাগুলি প্রস্তুত হয়, সম্পূর্ণ বার্তা প্রস্তুত হওয়ার জন্য অপেক্ষা না করে।

**কীভাবে কাজ করে:**

- সার্ভার প্রতিটি বার্তা প্রস্তুত হওয়ার সাথে সাথে পাঠায়।
- ক্লায়েন্ট প্রতিটি অংশ আসার সাথে সাথে গ্রহণ করে এবং প্রিন্ট করে।

**প্রয়োজনীয়তা:**

- সার্ভারকে একটি স্ট্রিমিং রেসপন্স ব্যবহার করতে হবে (যেমন, FastAPI-তে `StreamingResponse`)।
- ক্লায়েন্টকে রেসপন্স স্ট্রিম হিসাবে প্রক্রিয়া করতে হবে (`stream=True` requests-এ)।
- Content-Type সাধারণত `text/event-stream` বা `application/octet-stream` হয়।

#### জাভা

**সার্ভার (জাভা, Spring Boot এবং Server-Sent Events ব্যবহার করে):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**ক্লায়েন্ট (জাভা, Spring WebFlux WebClient ব্যবহার করে):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**জাভা বাস্তবায়ন নোট:**

- Spring Boot-এর রিয়েক্টিভ স্ট্যাক `Flux` ব্যবহার করে স্ট্রিমিং সক্ষম করে।
- `ServerSentEvent` ইভেন্ট টাইপ সহ কাঠামোগত ইভেন্ট স্ট্রিমিং প্রদান করে।
- `WebClient`-এর `bodyToFlux()` রিয়েক্টিভ স্ট্রিমিং গ্রহণ সক্ষম করে।
- `delayElements()` ইভেন্টগুলির মধ্যে প্রসেসিং সময় অনুকরণ করে।
- ইভেন্টগুলির টাইপ থাকতে পারে (`info`, `result`) যা ক্লায়েন্ট হ্যান্ডলিং উন্নত করে।

### তুলনা: ক্লাসিক স্ট্রিমিং বনাম MCP স্ট্রিমিং

ক্লাসিক পদ্ধতিতে স্ট্রিমিং এবং MCP-তে স্ট্রিমিংয়ের মধ্যে পার্থক্য নিম্নরূপ:

| বৈশিষ্ট্য              | ক্লাসিক HTTP স্ট্রিমিং         | MCP স্ট্রিমিং (নোটিফিকেশন)         |
|------------------------|-------------------------------|-------------------------------------|
| প্রধান রেসপন্স         | চাঙ্কড                        | একক, শেষে                          |
| প্রগ্রেস আপডেট         | ডেটা চাঙ্ক হিসাবে পাঠানো হয়   | নোটিফিকেশন হিসাবে পাঠানো হয়       |
| ক্লায়েন্টের প্রয়োজনীয়তা | স্ট্রিম প্রক্রিয়া করতে হবে    | মেসেজ হ্যান্ডলার বাস্তবায়ন করতে হবে |
| ব্যবহারের ক্ষেত্র       | বড় ফাইল, AI টোকেন স্ট্রিম    | প্রগ্রেস, লগ, রিয়েল-টাইম ফিডব্যাক |

### পর্যবেক্ষিত মূল পার্থক্য

অতিরিক্তভাবে, কিছু মূল পার্থক্য:

- **যোগাযোগ প্যাটার্ন:**
  - ক্লাসিক HTTP স্ট্রিমিং: ডেটা চাঙ্কে পাঠাতে সহজ চাঙ্কড ট্রান্সফার এনকোডিং ব্যবহার করে।
  - MCP স্ট্রিমিং: JSON-RPC প্রোটোকল সহ কাঠামোগত নোটিফিকেশন সিস্টেম ব্যবহার করে।

- **মেসেজ ফরম্যাট:**
  - ক্লাসিক HTTP: নতুন লাইনের সাথে প্লেইন টেক্সট চাঙ্ক।
  - MCP: মেটাডেটাসহ কাঠামোগত LoggingMessageNotification অবজেক্ট।

- **ক্লায়েন্ট বাস্তবায়ন:**
  - ক্লাসিক HTTP: স্ট্রিমিং রেসপন্স প্রক্রিয়া করার জন্য সহজ ক্লায়েন্ট।
  - MCP: বিভিন্ন ধরনের মেসেজ প্রক্রিয়াকরণের জন্য মেসেজ হ্যান্ডলার সহ আরও উন্নত ক্লায়েন্ট।

- **প্রগ্রেস আপডেট:**
  - ক্লাসিক HTTP: প্রগ্রেস প্রধান রেসপন্স স্ট্রিমের অংশ।
  - MCP: প্রগ্রেস পৃথক নোটিফিকেশন মেসেজের মাধ্যমে পাঠানো হয়, প্রধান রেসপন্স শেষে আসে।

### সুপারিশ

ক্লাসিক স্ট্রিমিং (যেমন `/stream` এন্ডপয়েন্ট) এবং MCP স্ট্রিমিংয়ের মধ্যে বেছে নেওয়ার সময় কিছু সুপারিশ:

- **সরল স্ট্রিমিং প্রয়োজনের জন্য:** ক্লাসিক HTTP স্ট্রিমিং সহজে বাস্তবায়নযোগ্য এবং মৌলিক স্ট্রিমিং প্রয়োজনের জন্য যথেষ্ট।
- **জটিল, ইন্টারঅ্যাকটিভ অ্যাপ্লিকেশনের জন্য:** MCP স্ট্রিমিং একটি আরও কাঠামোগত পদ্ধতি প্রদান করে, যা সমৃদ্ধ মেটাডেটা এবং নোটিফিকেশন ও চূড়ান্ত ফলাফলের মধ্যে পৃথকীকরণ করে।
- **AI অ্যাপ্লিকেশনের জন্য:** MCP-এর নোটিফিকেশন সিস্টেম দীর্ঘমেয়াদী AI কাজের জন্য বিশেষভাবে উপযোগী, যেখানে ব্যবহারকারীদের প্রগ্রেস সম্পর্কে অবহিত রাখা প্রয়োজন।
Streamable HTTP-এ SSE থেকে আপগ্রেড করার দুটি গুরুত্বপূর্ণ কারণ রয়েছে:

- Streamable HTTP, SSE-এর তুলনায় আরও ভালো স্কেলেবিলিটি, সামঞ্জস্যতা এবং উন্নত নোটিফিকেশন সাপোর্ট প্রদান করে।
- এটি নতুন MCP অ্যাপ্লিকেশনের জন্য সুপারিশকৃত ট্রান্সপোর্ট।

### মাইগ্রেশন ধাপসমূহ

আপনার MCP অ্যাপ্লিকেশনগুলোতে SSE থেকে Streamable HTTP-এ মাইগ্রেট করার জন্য নিচের ধাপগুলো অনুসরণ করুন:

- **সার্ভার কোড আপডেট করুন** `mcp.run()`-এ `transport="streamable-http"` ব্যবহার করে।
- **ক্লায়েন্ট কোড আপডেট করুন** SSE ক্লায়েন্টের পরিবর্তে `streamablehttp_client` ব্যবহার করে।
- **ক্লায়েন্টে একটি মেসেজ হ্যান্ডলার বাস্তবায়ন করুন** নোটিফিকেশন প্রক্রিয়াকরণের জন্য।
- **বিদ্যমান টুল এবং ওয়ার্কফ্লোগুলোর সাথে সামঞ্জস্যতা পরীক্ষা করুন।**

### সামঞ্জস্যতা বজায় রাখা

মাইগ্রেশন প্রক্রিয়ার সময় বিদ্যমান SSE ক্লায়েন্টগুলোর সাথে সামঞ্জস্যতা বজায় রাখা সুপারিশ করা হয়। এখানে কিছু কৌশল দেওয়া হলো:

- SSE এবং Streamable HTTP উভয়ই সমর্থন করতে পারেন, আলাদা এন্ডপয়েন্টে উভয় ট্রান্সপোর্ট চালিয়ে।
- ধীরে ধীরে ক্লায়েন্টগুলোকে নতুন ট্রান্সপোর্টে মাইগ্রেট করুন।

### চ্যালেঞ্জসমূহ

মাইগ্রেশনের সময় নিচের চ্যালেঞ্জগুলো সমাধান নিশ্চিত করুন:

- সমস্ত ক্লায়েন্ট আপডেট করা
- নোটিফিকেশন ডেলিভারির পার্থক্যগুলো পরিচালনা করা

## নিরাপত্তা বিবেচনা

HTTP-ভিত্তিক ট্রান্সপোর্ট যেমন Streamable HTTP ব্যবহার করার সময় MCP সার্ভার বাস্তবায়নে নিরাপত্তা সর্বোচ্চ অগ্রাধিকার হওয়া উচিত।

HTTP-ভিত্তিক ট্রান্সপোর্ট ব্যবহার করে MCP সার্ভার বাস্তবায়নের সময়, বিভিন্ন আক্রমণ ভেক্টর এবং সুরক্ষা পদ্ধতির প্রতি সতর্ক মনোযোগ প্রয়োজন।

### সংক্ষিপ্ত বিবরণ

HTTP-এর মাধ্যমে MCP সার্ভার প্রকাশ করার সময় নিরাপত্তা অত্যন্ত গুরুত্বপূর্ণ। Streamable HTTP নতুন আক্রমণ পৃষ্ঠ তৈরি করে এবং সাবধানতার সাথে কনফিগারেশন প্রয়োজন।

নিচে কিছু গুরুত্বপূর্ণ নিরাপত্তা বিবেচনা দেওয়া হলো:

- **Origin হেডার যাচাই**: DNS রিবাইন্ডিং আক্রমণ প্রতিরোধ করতে `Origin` হেডার যাচাই করুন।
- **Localhost বাইন্ডিং**: স্থানীয় ডেভেলপমেন্টের জন্য, সার্ভারগুলোকে `localhost`-এ বাইন্ড করুন যাতে পাবলিক ইন্টারনেটে প্রকাশ না হয়।
- **প্রমাণীকরণ**: প্রোডাকশন ডিপ্লয়মেন্টের জন্য প্রমাণীকরণ (যেমন API কী, OAuth) বাস্তবায়ন করুন।
- **CORS**: Cross-Origin Resource Sharing (CORS) পলিসি কনফিগার করুন অ্যাক্সেস সীমিত করতে।
- **HTTPS**: প্রোডাকশনে HTTPS ব্যবহার করুন ট্রাফিক এনক্রিপ্ট করতে।

### সেরা অনুশীলন

এছাড়াও, MCP স্ট্রিমিং সার্ভারে নিরাপত্তা বাস্তবায়নের সময় নিচের সেরা অনুশীলনগুলো অনুসরণ করুন:

- যাচাই ছাড়া আসা অনুরোধগুলোর উপর কখনোই বিশ্বাস করবেন না।
- সমস্ত অ্যাক্সেস এবং ত্রুটি লগ এবং মনিটর করুন।
- নিরাপত্তা দুর্বলতা প্যাচ করতে নিয়মিত ডিপেনডেন্সি আপডেট করুন।

### চ্যালেঞ্জসমূহ

MCP স্ট্রিমিং সার্ভারে নিরাপত্তা বাস্তবায়নের সময় কিছু চ্যালেঞ্জের মুখোমুখি হতে পারেন:

- উন্নয়নের সহজতার সাথে নিরাপত্তার ভারসাম্য বজায় রাখা
- বিভিন্ন ক্লায়েন্ট পরিবেশের সাথে সামঞ্জস্য নিশ্চিত করা

### অ্যাসাইনমেন্ট: আপনার নিজস্ব স্ট্রিমিং MCP অ্যাপ তৈরি করুন

**পরিস্থিতি:**
একটি MCP সার্ভার এবং ক্লায়েন্ট তৈরি করুন যেখানে সার্ভার একটি আইটেমের তালিকা (যেমন ফাইল বা ডকুমেন্ট) প্রক্রিয়া করে এবং প্রতিটি প্রক্রিয়াকৃত আইটেমের জন্য একটি নোটিফিকেশন পাঠায়। ক্লায়েন্ট প্রতিটি নোটিফিকেশন আসার সাথে সাথে প্রদর্শন করবে।

**ধাপসমূহ:**

1. একটি সার্ভার টুল বাস্তবায়ন করুন যা একটি তালিকা প্রক্রিয়া করে এবং প্রতিটি আইটেমের জন্য নোটিফিকেশন পাঠায়।
2. একটি ক্লায়েন্ট বাস্তবায়ন করুন যা একটি মেসেজ হ্যান্ডলার দিয়ে রিয়েল টাইমে নোটিফিকেশন প্রদর্শন করে।
3. আপনার বাস্তবায়ন পরীক্ষা করুন সার্ভার এবং ক্লায়েন্ট চালিয়ে এবং নোটিফিকেশন পর্যবেক্ষণ করুন।

[Solution](./solution/README.md)

## আরও পড়াশোনা এবং পরবর্তী কী?

MCP স্ট্রিমিং নিয়ে আপনার যাত্রা চালিয়ে যেতে এবং আরও উন্নত অ্যাপ্লিকেশন তৈরি করার জন্য আপনার জ্ঞান প্রসারিত করতে এই বিভাগটি অতিরিক্ত রিসোর্স এবং পরবর্তী পদক্ষেপের পরামর্শ প্রদান করে।

### আরও পড়াশোনা

- [Microsoft: HTTP স্ট্রিমিং পরিচিতি](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: ASP.NET Core-এ CORS](https://learn.microsoft.com/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: স্ট্রিমিং অনুরোধ](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### পরবর্তী কী?

- রিয়েল-টাইম অ্যানালিটিক্স, চ্যাট বা সহযোগী সম্পাদনার জন্য স্ট্রিমিং ব্যবহার করে আরও উন্নত MCP টুল তৈরি করার চেষ্টা করুন।
- লাইভ UI আপডেটের জন্য MCP স্ট্রিমিংকে ফ্রন্টএন্ড ফ্রেমওয়ার্ক (React, Vue, ইত্যাদি)-এর সাথে ইন্টিগ্রেট করার চেষ্টা করুন।
- পরবর্তী: [VSCode-এর জন্য AI Toolkit ব্যবহার](../07-aitk/README.md)

**অস্বীকৃতি**:  
এই নথিটি AI অনুবাদ পরিষেবা [Co-op Translator](https://github.com/Azure/co-op-translator) ব্যবহার করে অনুবাদ করা হয়েছে। আমরা যথাসম্ভব সঠিক অনুবাদের চেষ্টা করি, তবে অনুগ্রহ করে মনে রাখবেন যে স্বয়ংক্রিয় অনুবাদে ত্রুটি বা অসঙ্গতি থাকতে পারে। নথিটির মূল ভাষায় লেখা সংস্করণটিকেই প্রামাণিক উৎস হিসেবে বিবেচনা করা উচিত। গুরুত্বপূর্ণ তথ্যের জন্য পেশাদার মানব অনুবাদ সুপারিশ করা হয়। এই অনুবাদ ব্যবহারের ফলে সৃষ্ট কোনো ভুল বোঝাবুঝি বা ভুল ব্যাখ্যার জন্য আমরা দায়ী নই।